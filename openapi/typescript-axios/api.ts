/* tslint:disable */
/* eslint-disable */
/**
 * Noted API Documentation
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountsAPIUpdateAccountRequest
 */
export interface AccountsAPIUpdateAccountRequest {
    /**
     * 
     * @type {V1Account}
     * @memberof AccountsAPIUpdateAccountRequest
     */
    'account'?: V1Account;
    /**
     * 
     * @type {string}
     * @memberof AccountsAPIUpdateAccountRequest
     */
    'updateMask'?: string;
}
/**
 * 
 * @export
 * @interface BlockCode
 */
export interface BlockCode {
    /**
     * 
     * @type {string}
     * @memberof BlockCode
     */
    'snippet'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockCode
     */
    'lang'?: string;
}
/**
 * 
 * @export
 * @interface BlockImage
 */
export interface BlockImage {
    /**
     * 
     * @type {string}
     * @memberof BlockImage
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockImage
     */
    'caption'?: string;
}
/**
 * 
 * @export
 * @interface GroupsAPIUpdateGroupRequest
 */
export interface GroupsAPIUpdateGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsAPIUpdateGroupRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupsAPIUpdateGroupRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface NotesAPICreateNoteRequest
 */
export interface NotesAPICreateNoteRequest {
    /**
     * 
     * @type {string}
     * @memberof NotesAPICreateNoteRequest
     */
    'title'?: string;
    /**
     * 
     * @type {Array<V1Block>}
     * @memberof NotesAPICreateNoteRequest
     */
    'blocks'?: Array<V1Block>;
}
/**
 * 
 * @export
 * @interface V1AcceptInviteResponse
 */
export interface V1AcceptInviteResponse {
    /**
     * 
     * @type {V1GroupMember}
     * @memberof V1AcceptInviteResponse
     */
    'member'?: V1GroupMember;
}
/**
 * 
 * @export
 * @interface V1Account
 */
export interface V1Account {
    /**
     * 
     * @type {string}
     * @memberof V1Account
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Account
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Account
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface V1AuthenticateRequest
 */
export interface V1AuthenticateRequest {
    /**
     * 
     * @type {string}
     * @memberof V1AuthenticateRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AuthenticateRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface V1AuthenticateResponse
 */
export interface V1AuthenticateResponse {
    /**
     * 
     * @type {string}
     * @memberof V1AuthenticateResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface V1Block
 */
export interface V1Block {
    /**
     * 
     * @type {string}
     * @memberof V1Block
     */
    'id'?: string;
    /**
     * 
     * @type {V1BlockType}
     * @memberof V1Block
     */
    'type'?: V1BlockType;
    /**
     * 
     * @type {string}
     * @memberof V1Block
     */
    'heading'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Block
     */
    'paragraph'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Block
     */
    'numberPoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Block
     */
    'bulletPoint'?: string;
    /**
     * 
     * @type {BlockImage}
     * @memberof V1Block
     */
    'image'?: BlockImage;
    /**
     * 
     * @type {BlockCode}
     * @memberof V1Block
     */
    'code'?: BlockCode;
    /**
     * 
     * @type {string}
     * @memberof V1Block
     */
    'math'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const V1BlockType = {
    Heading1: 'TYPE_HEADING_1',
    Heading2: 'TYPE_HEADING_2',
    Heading3: 'TYPE_HEADING_3',
    Paragraph: 'TYPE_PARAGRAPH',
    Math: 'TYPE_MATH',
    Code: 'TYPE_CODE',
    BulletPoint: 'TYPE_BULLET_POINT',
    NumberPoint: 'TYPE_NUMBER_POINT',
    Image: 'TYPE_IMAGE'
} as const;

export type V1BlockType = typeof V1BlockType[keyof typeof V1BlockType];


/**
 * 
 * @export
 * @interface V1ConversationMessage
 */
export interface V1ConversationMessage {
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'conversationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'senderAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'modifiedAt'?: string;
}
/**
 * 
 * @export
 * @interface V1CreateAccountRequest
 */
export interface V1CreateAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreateAccountRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateAccountRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateAccountRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface V1CreateAccountResponse
 */
export interface V1CreateAccountResponse {
    /**
     * 
     * @type {V1Account}
     * @memberof V1CreateAccountResponse
     */
    'account'?: V1Account;
}
/**
 * 
 * @export
 * @interface V1CreateGroupRequest
 */
export interface V1CreateGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreateGroupRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateGroupRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface V1CreateGroupResponse
 */
export interface V1CreateGroupResponse {
    /**
     * 
     * @type {V1Group}
     * @memberof V1CreateGroupResponse
     */
    'group'?: V1Group;
}
/**
 * 
 * @export
 * @interface V1CreateNoteResponse
 */
export interface V1CreateNoteResponse {
    /**
     * 
     * @type {V1Note}
     * @memberof V1CreateNoteResponse
     */
    'note'?: V1Note;
}
/**
 * 
 * @export
 * @interface V1CreateWorkspaceResponse
 */
export interface V1CreateWorkspaceResponse {
    /**
     * 
     * @type {V1Group}
     * @memberof V1CreateWorkspaceResponse
     */
    'group'?: V1Group;
}
/**
 * 
 * @export
 * @interface V1DefinitionWidget
 */
export interface V1DefinitionWidget {
    /**
     * 
     * @type {string}
     * @memberof V1DefinitionWidget
     */
    'word'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1DefinitionWidget
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1DefinitionWidget
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1DefinitionWidget
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface V1ExportNoteResponse
 */
export interface V1ExportNoteResponse {
    /**
     * 
     * @type {string}
     * @memberof V1ExportNoteResponse
     */
    'file'?: string;
}
/**
 * 
 * @export
 * @interface V1ExtractKeywordsBatchResponse
 */
export interface V1ExtractKeywordsBatchResponse {
    /**
     * 
     * @type {Array<V1ExtractKeywordsResponse>}
     * @memberof V1ExtractKeywordsBatchResponse
     */
    'keywordsArray'?: Array<V1ExtractKeywordsResponse>;
}
/**
 * 
 * @export
 * @interface V1ExtractKeywordsResponse
 */
export interface V1ExtractKeywordsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ExtractKeywordsResponse
     */
    'keywords'?: Array<string>;
}
/**
 * 
 * @export
 * @interface V1GenerateInviteLinkResponse
 */
export interface V1GenerateInviteLinkResponse {
    /**
     * 
     * @type {V1GroupInviteLink}
     * @memberof V1GenerateInviteLinkResponse
     */
    'inviteLink'?: V1GroupInviteLink;
}
/**
 * 
 * @export
 * @interface V1GenerateWidgetsResponse
 */
export interface V1GenerateWidgetsResponse {
    /**
     * 
     * @type {Array<V1Widget>}
     * @memberof V1GenerateWidgetsResponse
     */
    'widgets'?: Array<V1Widget>;
}
/**
 * 
 * @export
 * @interface V1GetAccountResponse
 */
export interface V1GetAccountResponse {
    /**
     * 
     * @type {V1Account}
     * @memberof V1GetAccountResponse
     */
    'account'?: V1Account;
}
/**
 * 
 * @export
 * @interface V1GetConversationMessageResponse
 */
export interface V1GetConversationMessageResponse {
    /**
     * 
     * @type {V1ConversationMessage}
     * @memberof V1GetConversationMessageResponse
     */
    'message'?: V1ConversationMessage;
}
/**
 * 
 * @export
 * @interface V1GetConversationResponse
 */
export interface V1GetConversationResponse {
    /**
     * 
     * @type {V1GroupConversation}
     * @memberof V1GetConversationResponse
     */
    'conversation'?: V1GroupConversation;
}
/**
 * 
 * @export
 * @interface V1GetGroupResponse
 */
export interface V1GetGroupResponse {
    /**
     * 
     * @type {V1Group}
     * @memberof V1GetGroupResponse
     */
    'group'?: V1Group;
}
/**
 * 
 * @export
 * @interface V1GetInviteLinkResponse
 */
export interface V1GetInviteLinkResponse {
    /**
     * 
     * @type {V1GroupInviteLink}
     * @memberof V1GetInviteLinkResponse
     */
    'inviteLink'?: V1GroupInviteLink;
}
/**
 * 
 * @export
 * @interface V1GetInviteResponse
 */
export interface V1GetInviteResponse {
    /**
     * 
     * @type {V1GroupInvite}
     * @memberof V1GetInviteResponse
     */
    'invite'?: V1GroupInvite;
}
/**
 * 
 * @export
 * @interface V1GetMemberResponse
 */
export interface V1GetMemberResponse {
    /**
     * 
     * @type {V1GroupMember}
     * @memberof V1GetMemberResponse
     */
    'member'?: V1GroupMember;
}
/**
 * 
 * @export
 * @interface V1GetNoteResponse
 */
export interface V1GetNoteResponse {
    /**
     * 
     * @type {V1Note}
     * @memberof V1GetNoteResponse
     */
    'note'?: V1Note;
}
/**
 * 
 * @export
 * @interface V1Group
 */
export interface V1Group {
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'workspaceAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'modifiedAt'?: string;
    /**
     * 
     * @type {Array<V1GroupMember>}
     * @memberof V1Group
     */
    'members'?: Array<V1GroupMember>;
    /**
     * 
     * @type {Array<V1GroupConversation>}
     * @memberof V1Group
     */
    'conversations'?: Array<V1GroupConversation>;
    /**
     * 
     * @type {Array<V1GroupInvite>}
     * @memberof V1Group
     */
    'invites'?: Array<V1GroupInvite>;
    /**
     * 
     * @type {Array<V1GroupInviteLink>}
     * @memberof V1Group
     */
    'inviteLinks'?: Array<V1GroupInviteLink>;
}
/**
 * 
 * @export
 * @interface V1GroupConversation
 */
export interface V1GroupConversation {
    /**
     * 
     * @type {string}
     * @memberof V1GroupConversation
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupConversation
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupConversation
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface V1GroupInvite
 */
export interface V1GroupInvite {
    /**
     * 
     * @type {string}
     * @memberof V1GroupInvite
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInvite
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInvite
     */
    'senderAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInvite
     */
    'recipientAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInvite
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInvite
     */
    'validUntil'?: string;
}
/**
 * 
 * @export
 * @interface V1GroupInviteLink
 */
export interface V1GroupInviteLink {
    /**
     * 
     * @type {string}
     * @memberof V1GroupInviteLink
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInviteLink
     */
    'generatedByAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInviteLink
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInviteLink
     */
    'validUntil'?: string;
}
/**
 * 
 * @export
 * @interface V1GroupMember
 */
export interface V1GroupMember {
    /**
     * 
     * @type {string}
     * @memberof V1GroupMember
     */
    'accountId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1GroupMember
     */
    'isAdmin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1GroupMember
     */
    'joinedAt'?: string;
}
/**
 * 
 * @export
 * @interface V1HttpError
 */
export interface V1HttpError {
    /**
     * 
     * @type {string}
     * @memberof V1HttpError
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface V1ImageWidget
 */
export interface V1ImageWidget {
    /**
     * 
     * @type {string}
     * @memberof V1ImageWidget
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ImageWidget
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ImageWidget
     */
    'caption'?: string;
}
/**
 * 
 * @export
 * @interface V1InsertBlockResponse
 */
export interface V1InsertBlockResponse {
    /**
     * 
     * @type {V1Block}
     * @memberof V1InsertBlockResponse
     */
    'block'?: V1Block;
}
/**
 * 
 * @export
 * @interface V1ListAccountsResponse
 */
export interface V1ListAccountsResponse {
    /**
     * 
     * @type {Array<V1Account>}
     * @memberof V1ListAccountsResponse
     */
    'accounts'?: Array<V1Account>;
}
/**
 * 
 * @export
 * @interface V1ListConversationMessagesResponse
 */
export interface V1ListConversationMessagesResponse {
    /**
     * 
     * @type {Array<V1ConversationMessage>}
     * @memberof V1ListConversationMessagesResponse
     */
    'messages'?: Array<V1ConversationMessage>;
}
/**
 * 
 * @export
 * @interface V1ListGroupsResponse
 */
export interface V1ListGroupsResponse {
    /**
     * 
     * @type {Array<V1Group>}
     * @memberof V1ListGroupsResponse
     */
    'groups'?: Array<V1Group>;
}
/**
 * 
 * @export
 * @interface V1ListInvitesResponse
 */
export interface V1ListInvitesResponse {
    /**
     * 
     * @type {Array<V1GroupInvite>}
     * @memberof V1ListInvitesResponse
     */
    'invites'?: Array<V1GroupInvite>;
}
/**
 * 
 * @export
 * @interface V1ListNotesResponse
 */
export interface V1ListNotesResponse {
    /**
     * 
     * @type {Array<V1Note>}
     * @memberof V1ListNotesResponse
     */
    'notes'?: Array<V1Note>;
}
/**
 * 
 * @export
 * @interface V1Note
 */
export interface V1Note {
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'authorAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'title'?: string;
    /**
     * 
     * @type {Array<V1Block>}
     * @memberof V1Note
     */
    'blocks'?: Array<V1Block>;
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'modifiedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'analyzedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const V1NoteExportFormat = {
    Markdown: 'NOTE_EXPORT_FORMAT_MARKDOWN',
    Pdf: 'NOTE_EXPORT_FORMAT_PDF'
} as const;

export type V1NoteExportFormat = typeof V1NoteExportFormat[keyof typeof V1NoteExportFormat];


/**
 * 
 * @export
 * @interface V1Recipient
 */
export interface V1Recipient {
    /**
     * 
     * @type {string}
     * @memberof V1Recipient
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface V1SendConversationMessageResponse
 */
export interface V1SendConversationMessageResponse {
    /**
     * 
     * @type {V1ConversationMessage}
     * @memberof V1SendConversationMessageResponse
     */
    'message'?: V1ConversationMessage;
}
/**
 * 
 * @export
 * @interface V1SendInviteResponse
 */
export interface V1SendInviteResponse {
    /**
     * 
     * @type {V1GroupInvite}
     * @memberof V1SendInviteResponse
     */
    'invite'?: V1GroupInvite;
}
/**
 * 
 * @export
 * @interface V1SummarizeResponse
 */
export interface V1SummarizeResponse {
    /**
     * Small text output which summarizes the original entry.
     * @type {string}
     * @memberof V1SummarizeResponse
     */
    'summary'?: string;
}
/**
 * 
 * @export
 * @interface V1UpdateAccountResponse
 */
export interface V1UpdateAccountResponse {
    /**
     * 
     * @type {V1Account}
     * @memberof V1UpdateAccountResponse
     */
    'account'?: V1Account;
}
/**
 * 
 * @export
 * @interface V1UpdateBlockResponse
 */
export interface V1UpdateBlockResponse {
    /**
     * 
     * @type {V1Block}
     * @memberof V1UpdateBlockResponse
     */
    'block'?: V1Block;
}
/**
 * 
 * @export
 * @interface V1UpdateConversationMessageResponse
 */
export interface V1UpdateConversationMessageResponse {
    /**
     * 
     * @type {V1ConversationMessage}
     * @memberof V1UpdateConversationMessageResponse
     */
    'message'?: V1ConversationMessage;
}
/**
 * 
 * @export
 * @interface V1UpdateConversationResponse
 */
export interface V1UpdateConversationResponse {
    /**
     * 
     * @type {V1GroupConversation}
     * @memberof V1UpdateConversationResponse
     */
    'conversation'?: V1GroupConversation;
}
/**
 * 
 * @export
 * @interface V1UpdateGroupResponse
 */
export interface V1UpdateGroupResponse {
    /**
     * 
     * @type {V1Group}
     * @memberof V1UpdateGroupResponse
     */
    'group'?: V1Group;
}
/**
 * 
 * @export
 * @interface V1UpdateMemberResponse
 */
export interface V1UpdateMemberResponse {
    /**
     * 
     * @type {V1GroupMember}
     * @memberof V1UpdateMemberResponse
     */
    'member'?: V1GroupMember;
}
/**
 * 
 * @export
 * @interface V1UpdateNoteResponse
 */
export interface V1UpdateNoteResponse {
    /**
     * 
     * @type {V1Note}
     * @memberof V1UpdateNoteResponse
     */
    'note'?: V1Note;
}
/**
 * 
 * @export
 * @interface V1WebsiteWidget
 */
export interface V1WebsiteWidget {
    /**
     * 
     * @type {string}
     * @memberof V1WebsiteWidget
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1WebsiteWidget
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1WebsiteWidget
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface V1Widget
 */
export interface V1Widget {
    /**
     * 
     * @type {V1WebsiteWidget}
     * @memberof V1Widget
     */
    'websiteWidget'?: V1WebsiteWidget;
    /**
     * 
     * @type {V1ImageWidget}
     * @memberof V1Widget
     */
    'imageWidget'?: V1ImageWidget;
    /**
     * 
     * @type {V1DefinitionWidget}
     * @memberof V1Widget
     */
    'definitionWidget'?: V1DefinitionWidget;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate using the email and password flow.
         * @param {V1AuthenticateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIAuthenticate: async (body: V1AuthenticateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAPIAuthenticate', 'body', body)
            const localVarPath = `/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an account using the email and password flow.
         * @param {V1CreateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPICreateAccount: async (body: V1CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAPICreateAccount', 'body', body)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be account owner.
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIDeleteAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAPIDeleteAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be authenticated.
         * @param {string} accountId 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIGetAccount: async (accountId: string, email?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAPIGetAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List users based on email regex.
         * @param {string} [emailContains] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIListAccounts: async (emailContains?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (emailContains !== undefined) {
                localVarQueryParameter['emailContains'] = emailContains;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be account owner. Can only update `account.name`.
         * @param {string} accountId 
         * @param {AccountsAPIUpdateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIUpdateAccount: async (accountId: string, body: AccountsAPIUpdateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAPIUpdateAccount', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAPIUpdateAccount', 'body', body)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a group with a single administrator member (the authenticated user). Must be authenticated.
         * @param {V1CreateGroupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPICreateGroup: async (body: V1CreateGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('groupsAPICreateGroup', 'body', body)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group administrator. Deletes all the associated resources (members, notes).
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIDeleteGroup: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIDeleteGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group member. If the caller is not a member but has been invited to the group or has an invite code link, it will access a limited view of the group.
         * @param {string} groupId 
         * @param {string} [inviteLinkCode] (Optional) If the requester isn\&#39;t a member of the group nor have they been invited directly, they can provide an invite_link_code that will give them a public preview of the group they wish to join.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGetGroup: async (groupId: string, inviteLinkCode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIGetGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inviteLinkCode !== undefined) {
                localVarQueryParameter['inviteLinkCode'] = inviteLinkCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group member. Returns only the non-array fields of a group.
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIListGroups: async (accountId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group administrator.
         * @param {string} groupId 
         * @param {GroupsAPIUpdateGroupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIUpdateGroup: async (groupId: string, body: GroupsAPIUpdateGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIUpdateGroup', 'groupId', groupId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('groupsAPIUpdateGroup', 'body', body)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group member, author_account_id defaults to the user making the request.
         * @param {string} groupId 
         * @param {NotesAPICreateNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPICreateNote: async (groupId: string, body: NotesAPICreateNoteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPICreateNote', 'groupId', groupId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('notesAPICreateNote', 'body', body)
            const localVarPath = `/groups/{groupId}/notes`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authenticate using the email and password flow.
         * @param {V1AuthenticateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIAuthenticate(body: V1AuthenticateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1AuthenticateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIAuthenticate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an account using the email and password flow.
         * @param {V1CreateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPICreateAccount(body: V1CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPICreateAccount(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be account owner.
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIDeleteAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIDeleteAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be authenticated.
         * @param {string} accountId 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIGetAccount(accountId: string, email?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIGetAccount(accountId, email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List users based on email regex.
         * @param {string} [emailContains] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIListAccounts(emailContains?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ListAccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIListAccounts(emailContains, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be account owner. Can only update `account.name`.
         * @param {string} accountId 
         * @param {AccountsAPIUpdateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIUpdateAccount(accountId: string, body: AccountsAPIUpdateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1UpdateAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIUpdateAccount(accountId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a group with a single administrator member (the authenticated user). Must be authenticated.
         * @param {V1CreateGroupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPICreateGroup(body: V1CreateGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPICreateGroup(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group administrator. Deletes all the associated resources (members, notes).
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIDeleteGroup(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIDeleteGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group member. If the caller is not a member but has been invited to the group or has an invite code link, it will access a limited view of the group.
         * @param {string} groupId 
         * @param {string} [inviteLinkCode] (Optional) If the requester isn\&#39;t a member of the group nor have they been invited directly, they can provide an invite_link_code that will give them a public preview of the group they wish to join.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIGetGroup(groupId: string, inviteLinkCode?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIGetGroup(groupId, inviteLinkCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group member. Returns only the non-array fields of a group.
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIListGroups(accountId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ListGroupsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIListGroups(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group administrator.
         * @param {string} groupId 
         * @param {GroupsAPIUpdateGroupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIUpdateGroup(groupId: string, body: GroupsAPIUpdateGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1UpdateGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIUpdateGroup(groupId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group member, author_account_id defaults to the user making the request.
         * @param {string} groupId 
         * @param {NotesAPICreateNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPICreateNote(groupId: string, body: NotesAPICreateNoteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateNoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPICreateNote(groupId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Authenticate using the email and password flow.
         * @param {V1AuthenticateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIAuthenticate(body: V1AuthenticateRequest, options?: any): AxiosPromise<V1AuthenticateResponse> {
            return localVarFp.accountsAPIAuthenticate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an account using the email and password flow.
         * @param {V1CreateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPICreateAccount(body: V1CreateAccountRequest, options?: any): AxiosPromise<V1CreateAccountResponse> {
            return localVarFp.accountsAPICreateAccount(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be account owner.
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIDeleteAccount(accountId: string, options?: any): AxiosPromise<object> {
            return localVarFp.accountsAPIDeleteAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be authenticated.
         * @param {string} accountId 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIGetAccount(accountId: string, email?: string, options?: any): AxiosPromise<V1GetAccountResponse> {
            return localVarFp.accountsAPIGetAccount(accountId, email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List users based on email regex.
         * @param {string} [emailContains] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIListAccounts(emailContains?: string, limit?: number, offset?: number, options?: any): AxiosPromise<V1ListAccountsResponse> {
            return localVarFp.accountsAPIListAccounts(emailContains, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be account owner. Can only update `account.name`.
         * @param {string} accountId 
         * @param {AccountsAPIUpdateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIUpdateAccount(accountId: string, body: AccountsAPIUpdateAccountRequest, options?: any): AxiosPromise<V1UpdateAccountResponse> {
            return localVarFp.accountsAPIUpdateAccount(accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a group with a single administrator member (the authenticated user). Must be authenticated.
         * @param {V1CreateGroupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPICreateGroup(body: V1CreateGroupRequest, options?: any): AxiosPromise<V1CreateGroupResponse> {
            return localVarFp.groupsAPICreateGroup(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group administrator. Deletes all the associated resources (members, notes).
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIDeleteGroup(groupId: string, options?: any): AxiosPromise<object> {
            return localVarFp.groupsAPIDeleteGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group member. If the caller is not a member but has been invited to the group or has an invite code link, it will access a limited view of the group.
         * @param {string} groupId 
         * @param {string} [inviteLinkCode] (Optional) If the requester isn\&#39;t a member of the group nor have they been invited directly, they can provide an invite_link_code that will give them a public preview of the group they wish to join.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGetGroup(groupId: string, inviteLinkCode?: string, options?: any): AxiosPromise<V1GetGroupResponse> {
            return localVarFp.groupsAPIGetGroup(groupId, inviteLinkCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group member. Returns only the non-array fields of a group.
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIListGroups(accountId?: string, options?: any): AxiosPromise<V1ListGroupsResponse> {
            return localVarFp.groupsAPIListGroups(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group administrator.
         * @param {string} groupId 
         * @param {GroupsAPIUpdateGroupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIUpdateGroup(groupId: string, body: GroupsAPIUpdateGroupRequest, options?: any): AxiosPromise<V1UpdateGroupResponse> {
            return localVarFp.groupsAPIUpdateGroup(groupId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group member, author_account_id defaults to the user making the request.
         * @param {string} groupId 
         * @param {NotesAPICreateNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPICreateNote(groupId: string, body: NotesAPICreateNoteRequest, options?: any): AxiosPromise<V1CreateNoteResponse> {
            return localVarFp.notesAPICreateNote(groupId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Authenticate using the email and password flow.
     * @param {V1AuthenticateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIAuthenticate(body: V1AuthenticateRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIAuthenticate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an account using the email and password flow.
     * @param {V1CreateAccountRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPICreateAccount(body: V1CreateAccountRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPICreateAccount(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be account owner.
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIDeleteAccount(accountId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIDeleteAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be authenticated.
     * @param {string} accountId 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIGetAccount(accountId: string, email?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIGetAccount(accountId, email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List users based on email regex.
     * @param {string} [emailContains] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIListAccounts(emailContains?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIListAccounts(emailContains, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be account owner. Can only update `account.name`.
     * @param {string} accountId 
     * @param {AccountsAPIUpdateAccountRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIUpdateAccount(accountId: string, body: AccountsAPIUpdateAccountRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIUpdateAccount(accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a group with a single administrator member (the authenticated user). Must be authenticated.
     * @param {V1CreateGroupRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPICreateGroup(body: V1CreateGroupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPICreateGroup(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group administrator. Deletes all the associated resources (members, notes).
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIDeleteGroup(groupId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIDeleteGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group member. If the caller is not a member but has been invited to the group or has an invite code link, it will access a limited view of the group.
     * @param {string} groupId 
     * @param {string} [inviteLinkCode] (Optional) If the requester isn\&#39;t a member of the group nor have they been invited directly, they can provide an invite_link_code that will give them a public preview of the group they wish to join.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIGetGroup(groupId: string, inviteLinkCode?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIGetGroup(groupId, inviteLinkCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group member. Returns only the non-array fields of a group.
     * @param {string} [accountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIListGroups(accountId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIListGroups(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group administrator.
     * @param {string} groupId 
     * @param {GroupsAPIUpdateGroupRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIUpdateGroup(groupId: string, body: GroupsAPIUpdateGroupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIUpdateGroup(groupId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group member, author_account_id defaults to the user making the request.
     * @param {string} groupId 
     * @param {NotesAPICreateNoteRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPICreateNote(groupId: string, body: NotesAPICreateNoteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPICreateNote(groupId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


