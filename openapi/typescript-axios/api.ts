/* tslint:disable */
/* eslint-disable */
/**
 * Noted API Documentation
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountsAPIUpdateAccountPasswordRequest
 */
export interface AccountsAPIUpdateAccountPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsAPIUpdateAccountPasswordRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AccountsAPIUpdateAccountPasswordRequest
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountsAPIUpdateAccountPasswordRequest
     */
    'oldPassword'?: string;
}
/**
 * 
 * @export
 * @interface AccountsAPIUploadAccountProfilePictureRequest
 */
export interface AccountsAPIUploadAccountProfilePictureRequest {
    /**
     * 
     * @type {Accountsv1Image}
     * @memberof AccountsAPIUploadAccountProfilePictureRequest
     */
    'image': Accountsv1Image;
}
/**
 * 
 * @export
 * @interface AccountsAPIValidateAccountRequest
 */
export interface AccountsAPIValidateAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsAPIValidateAccountRequest
     */
    'validationToken': string;
}
/**
 * 
 * @export
 * @interface Accountsv1Image
 */
export interface Accountsv1Image {
    /**
     * 
     * @type {string}
     * @memberof Accountsv1Image
     */
    'image': string;
    /**
     * 
     * @type {V1ImageType}
     * @memberof Accountsv1Image
     */
    'type': V1ImageType;
}


/**
 * 
 * @export
 * @interface BlockCode
 */
export interface BlockCode {
    /**
     * 
     * @type {string}
     * @memberof BlockCode
     */
    'snippet'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockCode
     */
    'lang'?: string;
}
/**
 * 
 * @export
 * @interface BlockComment
 */
export interface BlockComment {
    /**
     * 
     * @type {string}
     * @memberof BlockComment
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockComment
     */
    'authorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockComment
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface BlockTextStyle
 */
export interface BlockTextStyle {
    /**
     * 
     * @type {TextStyleStyle}
     * @memberof BlockTextStyle
     */
    'style'?: TextStyleStyle;
    /**
     * 
     * @type {TextStylePosition}
     * @memberof BlockTextStyle
     */
    'pos'?: TextStylePosition;
    /**
     * 
     * @type {TextStyleColor}
     * @memberof BlockTextStyle
     */
    'color'?: TextStyleColor;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ChangeNoteEditPermissionRequestAction = {
    Grant: 'ACTION_GRANT',
    Remove: 'ACTION_REMOVE'
} as const;

export type ChangeNoteEditPermissionRequestAction = typeof ChangeNoteEditPermissionRequestAction[keyof typeof ChangeNoteEditPermissionRequestAction];


/**
 * 
 * @export
 * @interface GroupsAPISendInviteRequest
 */
export interface GroupsAPISendInviteRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsAPISendInviteRequest
     */
    'recipientAccountId': string;
}
/**
 * 
 * @export
 * @interface GroupsAPIUpdateGroupRequest
 */
export interface GroupsAPIUpdateGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsAPIUpdateGroupRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupsAPIUpdateGroupRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface NotesAPIChangeNoteEditPermissionRequest
 */
export interface NotesAPIChangeNoteEditPermissionRequest {
    /**
     * 
     * @type {string}
     * @memberof NotesAPIChangeNoteEditPermissionRequest
     */
    'recipientAccountId': string;
    /**
     * 
     * @type {ChangeNoteEditPermissionRequestAction}
     * @memberof NotesAPIChangeNoteEditPermissionRequest
     */
    'type'?: ChangeNoteEditPermissionRequestAction;
}


/**
 * 
 * @export
 * @interface NotesAPICreateBlockCommentRequest
 */
export interface NotesAPICreateBlockCommentRequest {
    /**
     * 
     * @type {BlockComment}
     * @memberof NotesAPICreateBlockCommentRequest
     */
    'comment': BlockComment;
}
/**
 * 
 * @export
 * @interface NotesAPICreateNoteRequest
 */
export interface NotesAPICreateNoteRequest {
    /**
     * 
     * @type {string}
     * @memberof NotesAPICreateNoteRequest
     */
    'title'?: string;
    /**
     * 
     * @type {Array<V1Block>}
     * @memberof NotesAPICreateNoteRequest
     */
    'blocks'?: Array<V1Block>;
}
/**
 * 
 * @export
 * @interface NotesAPIInsertBlockRequest
 */
export interface NotesAPIInsertBlockRequest {
    /**
     * 
     * @type {number}
     * @memberof NotesAPIInsertBlockRequest
     */
    'index': number;
    /**
     * 
     * @type {V1Block}
     * @memberof NotesAPIInsertBlockRequest
     */
    'block': V1Block;
}
/**
 * 
 * @export
 * @interface NotesAPIUpdateBlockIndexRequest
 */
export interface NotesAPIUpdateBlockIndexRequest {
    /**
     * 
     * @type {number}
     * @memberof NotesAPIUpdateBlockIndexRequest
     */
    'index': number;
}
/**
 * 
 * @export
 * @interface StreamResultOfV1StreamInvitesResponse
 */
export interface StreamResultOfV1StreamInvitesResponse {
    /**
     * 
     * @type {V1StreamInvitesResponse}
     * @memberof StreamResultOfV1StreamInvitesResponse
     */
    'result'?: V1StreamInvitesResponse;
}
/**
 * 
 * @export
 * @interface TextStyleColor
 */
export interface TextStyleColor {
    /**
     * 
     * @type {number}
     * @memberof TextStyleColor
     */
    'r'?: number;
    /**
     * 
     * @type {number}
     * @memberof TextStyleColor
     */
    'g'?: number;
    /**
     * 
     * @type {number}
     * @memberof TextStyleColor
     */
    'b'?: number;
}
/**
 * 
 * @export
 * @interface TextStylePosition
 */
export interface TextStylePosition {
    /**
     * 
     * @type {string}
     * @memberof TextStylePosition
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextStylePosition
     */
    'length'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TextStyleStyle = {
    BgColor: 'STYLE_BG_COLOR',
    TxtColor: 'STYLE_TXT_COLOR',
    Bold: 'STYLE_BOLD',
    Italic: 'STYLE_ITALIC',
    Underline: 'STYLE_UNDERLINE'
} as const;

export type TextStyleStyle = typeof TextStyleStyle[keyof typeof TextStyleStyle];


/**
 * 
 * @export
 * @interface V1AcceptInviteResponse
 */
export interface V1AcceptInviteResponse {
    /**
     * 
     * @type {V1GroupMember}
     * @memberof V1AcceptInviteResponse
     */
    'member': V1GroupMember;
}
/**
 * 
 * @export
 * @interface V1Account
 */
export interface V1Account {
    /**
     * 
     * @type {string}
     * @memberof V1Account
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof V1Account
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof V1Account
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Account
     */
    'isInMobileBeta'?: boolean;
}
/**
 * 
 * @export
 * @interface V1AuthenticateGoogleRequest
 */
export interface V1AuthenticateGoogleRequest {
    /**
     * 
     * @type {string}
     * @memberof V1AuthenticateGoogleRequest
     */
    'clientAccessToken': string;
}
/**
 * 
 * @export
 * @interface V1AuthenticateGoogleResponse
 */
export interface V1AuthenticateGoogleResponse {
    /**
     * 
     * @type {string}
     * @memberof V1AuthenticateGoogleResponse
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface V1AuthenticateRequest
 */
export interface V1AuthenticateRequest {
    /**
     * 
     * @type {string}
     * @memberof V1AuthenticateRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof V1AuthenticateRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface V1AuthenticateResponse
 */
export interface V1AuthenticateResponse {
    /**
     * 
     * @type {string}
     * @memberof V1AuthenticateResponse
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface V1Block
 */
export interface V1Block {
    /**
     * 
     * @type {string}
     * @memberof V1Block
     */
    'id': string;
    /**
     * 
     * @type {V1BlockType}
     * @memberof V1Block
     */
    'type': V1BlockType;
    /**
     * 
     * @type {Array<BlockTextStyle>}
     * @memberof V1Block
     */
    'styles'?: Array<BlockTextStyle>;
    /**
     * 
     * @type {string}
     * @memberof V1Block
     */
    'heading'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Block
     */
    'paragraph'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Block
     */
    'numberPoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Block
     */
    'bulletPoint'?: string;
    /**
     * 
     * @type {V1BlockImage}
     * @memberof V1Block
     */
    'image'?: V1BlockImage;
    /**
     * 
     * @type {BlockCode}
     * @memberof V1Block
     */
    'code'?: BlockCode;
    /**
     * 
     * @type {string}
     * @memberof V1Block
     */
    'math'?: string;
    /**
     * 
     * @type {Array<BlockComment>}
     * @memberof V1Block
     */
    'thread'?: Array<BlockComment>;
}


/**
 * 
 * @export
 * @interface V1BlockImage
 */
export interface V1BlockImage {
    /**
     * 
     * @type {string}
     * @memberof V1BlockImage
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1BlockImage
     */
    'caption'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const V1BlockType = {
    Heading1: 'TYPE_HEADING_1',
    Heading2: 'TYPE_HEADING_2',
    Heading3: 'TYPE_HEADING_3',
    Paragraph: 'TYPE_PARAGRAPH',
    Math: 'TYPE_MATH',
    Code: 'TYPE_CODE',
    BulletPoint: 'TYPE_BULLET_POINT',
    NumberPoint: 'TYPE_NUMBER_POINT',
    Image: 'TYPE_IMAGE'
} as const;

export type V1BlockType = typeof V1BlockType[keyof typeof V1BlockType];


/**
 * 
 * @export
 * @interface V1ConversationMessage
 */
export interface V1ConversationMessage {
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'groupId': string;
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'conversationId': string;
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'senderAccountId': string;
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof V1ConversationMessage
     */
    'modifiedAt'?: string;
}
/**
 * 
 * @export
 * @interface V1CreateAccountRequest
 */
export interface V1CreateAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreateAccountRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateAccountRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateAccountRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface V1CreateAccountResponse
 */
export interface V1CreateAccountResponse {
    /**
     * 
     * @type {V1Account}
     * @memberof V1CreateAccountResponse
     */
    'account': V1Account;
}
/**
 * 
 * @export
 * @interface V1CreateBlockCommentResponse
 */
export interface V1CreateBlockCommentResponse {
    /**
     * 
     * @type {BlockComment}
     * @memberof V1CreateBlockCommentResponse
     */
    'comment'?: BlockComment;
}
/**
 * 
 * @export
 * @interface V1CreateGroupRequest
 */
export interface V1CreateGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CreateGroupRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof V1CreateGroupRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface V1CreateGroupResponse
 */
export interface V1CreateGroupResponse {
    /**
     * 
     * @type {V1Group}
     * @memberof V1CreateGroupResponse
     */
    'group': V1Group;
}
/**
 * 
 * @export
 * @interface V1CreateNoteResponse
 */
export interface V1CreateNoteResponse {
    /**
     * 
     * @type {V1Note}
     * @memberof V1CreateNoteResponse
     */
    'note': V1Note;
}
/**
 * 
 * @export
 * @interface V1CreateWorkspaceResponse
 */
export interface V1CreateWorkspaceResponse {
    /**
     * 
     * @type {V1Group}
     * @memberof V1CreateWorkspaceResponse
     */
    'group': V1Group;
}
/**
 * 
 * @export
 * @interface V1DefinitionWidget
 */
export interface V1DefinitionWidget {
    /**
     * 
     * @type {string}
     * @memberof V1DefinitionWidget
     */
    'word': string;
    /**
     * 
     * @type {string}
     * @memberof V1DefinitionWidget
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1DefinitionWidget
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1DefinitionWidget
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface V1ExportNoteResponse
 */
export interface V1ExportNoteResponse {
    /**
     * 
     * @type {string}
     * @memberof V1ExportNoteResponse
     */
    'file': string;
}
/**
 * 
 * @export
 * @interface V1ExtractKeywordsBatchResponse
 */
export interface V1ExtractKeywordsBatchResponse {
    /**
     * 
     * @type {Array<V1ExtractKeywordsResponse>}
     * @memberof V1ExtractKeywordsBatchResponse
     */
    'keywordsArray'?: Array<V1ExtractKeywordsResponse>;
}
/**
 * 
 * @export
 * @interface V1ExtractKeywordsResponse
 */
export interface V1ExtractKeywordsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ExtractKeywordsResponse
     */
    'keywords'?: Array<string>;
}
/**
 * 
 * @export
 * @interface V1ForgetAccountPasswordRequest
 */
export interface V1ForgetAccountPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ForgetAccountPasswordRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface V1ForgetAccountPasswordResponse
 */
export interface V1ForgetAccountPasswordResponse {
    /**
     * 
     * @type {string}
     * @memberof V1ForgetAccountPasswordResponse
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof V1ForgetAccountPasswordResponse
     */
    'validUntil': string;
}
/**
 * 
 * @export
 * @interface V1ForgetAccountPasswordValidateTokenRequest
 */
export interface V1ForgetAccountPasswordValidateTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ForgetAccountPasswordValidateTokenRequest
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof V1ForgetAccountPasswordValidateTokenRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface V1ForgetAccountPasswordValidateTokenResponse
 */
export interface V1ForgetAccountPasswordValidateTokenResponse {
    /**
     * 
     * @type {V1Account}
     * @memberof V1ForgetAccountPasswordValidateTokenResponse
     */
    'account': V1Account;
    /**
     * 
     * @type {string}
     * @memberof V1ForgetAccountPasswordValidateTokenResponse
     */
    'resetToken': string;
    /**
     * 
     * @type {string}
     * @memberof V1ForgetAccountPasswordValidateTokenResponse
     */
    'authToken': string;
}
/**
 * 
 * @export
 * @interface V1GenerateInviteLinkResponse
 */
export interface V1GenerateInviteLinkResponse {
    /**
     * 
     * @type {V1GroupInviteLink}
     * @memberof V1GenerateInviteLinkResponse
     */
    'inviteLink': V1GroupInviteLink;
}
/**
 * 
 * @export
 * @interface V1GenerateQuizResponse
 */
export interface V1GenerateQuizResponse {
    /**
     * 
     * @type {V1Quiz}
     * @memberof V1GenerateQuizResponse
     */
    'quiz'?: V1Quiz;
}
/**
 * 
 * @export
 * @interface V1GenerateSummaryResponse
 */
export interface V1GenerateSummaryResponse {
    /**
     * 
     * @type {string}
     * @memberof V1GenerateSummaryResponse
     */
    'summary'?: string;
}
/**
 * 
 * @export
 * @interface V1GenerateWidgetsResponse
 */
export interface V1GenerateWidgetsResponse {
    /**
     * 
     * @type {Array<V1Widget>}
     * @memberof V1GenerateWidgetsResponse
     */
    'widgets': Array<V1Widget>;
}
/**
 * 
 * @export
 * @interface V1GetAccountProfilePictureResponse
 */
export interface V1GetAccountProfilePictureResponse {
    /**
     * 
     * @type {string}
     * @memberof V1GetAccountProfilePictureResponse
     */
    'accountId': string;
    /**
     * 
     * @type {Accountsv1Image}
     * @memberof V1GetAccountProfilePictureResponse
     */
    'image': Accountsv1Image;
}
/**
 * 
 * @export
 * @interface V1GetAccountRequest
 */
export interface V1GetAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof V1GetAccountRequest
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GetAccountRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface V1GetAccountResponse
 */
export interface V1GetAccountResponse {
    /**
     * 
     * @type {V1Account}
     * @memberof V1GetAccountResponse
     */
    'account': V1Account;
}
/**
 * 
 * @export
 * @interface V1GetActivityResponse
 */
export interface V1GetActivityResponse {
    /**
     * 
     * @type {V1GroupActivity}
     * @memberof V1GetActivityResponse
     */
    'activity': V1GroupActivity;
}
/**
 * 
 * @export
 * @interface V1GetConversationMessageResponse
 */
export interface V1GetConversationMessageResponse {
    /**
     * 
     * @type {V1ConversationMessage}
     * @memberof V1GetConversationMessageResponse
     */
    'message': V1ConversationMessage;
}
/**
 * 
 * @export
 * @interface V1GetConversationResponse
 */
export interface V1GetConversationResponse {
    /**
     * 
     * @type {V1GroupConversation}
     * @memberof V1GetConversationResponse
     */
    'conversation': V1GroupConversation;
}
/**
 * 
 * @export
 * @interface V1GetGroupResponse
 */
export interface V1GetGroupResponse {
    /**
     * 
     * @type {V1Group}
     * @memberof V1GetGroupResponse
     */
    'group': V1Group;
}
/**
 * 
 * @export
 * @interface V1GetInviteLinkResponse
 */
export interface V1GetInviteLinkResponse {
    /**
     * 
     * @type {V1GroupInviteLink}
     * @memberof V1GetInviteLinkResponse
     */
    'inviteLink': V1GroupInviteLink;
}
/**
 * 
 * @export
 * @interface V1GetInviteResponse
 */
export interface V1GetInviteResponse {
    /**
     * 
     * @type {V1GroupInvite}
     * @memberof V1GetInviteResponse
     */
    'invite': V1GroupInvite;
}
/**
 * 
 * @export
 * @interface V1GetMailsFromIDsResponse
 */
export interface V1GetMailsFromIDsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1GetMailsFromIDsResponse
     */
    'emails'?: Array<string>;
}
/**
 * 
 * @export
 * @interface V1GetMemberResponse
 */
export interface V1GetMemberResponse {
    /**
     * 
     * @type {V1GroupMember}
     * @memberof V1GetMemberResponse
     */
    'member': V1GroupMember;
}
/**
 * 
 * @export
 * @interface V1GetNoteResponse
 */
export interface V1GetNoteResponse {
    /**
     * 
     * @type {V1Note}
     * @memberof V1GetNoteResponse
     */
    'note': V1Note;
}
/**
 * 
 * @export
 * @interface V1Group
 */
export interface V1Group {
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'workspaceAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'avatarUrl': string;
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof V1Group
     */
    'modifiedAt'?: string;
    /**
     * 
     * @type {Array<V1GroupMember>}
     * @memberof V1Group
     */
    'members'?: Array<V1GroupMember>;
    /**
     * 
     * @type {Array<V1GroupConversation>}
     * @memberof V1Group
     */
    'conversations'?: Array<V1GroupConversation>;
    /**
     * 
     * @type {Array<V1GroupInvite>}
     * @memberof V1Group
     */
    'invites'?: Array<V1GroupInvite>;
    /**
     * 
     * @type {Array<V1GroupInviteLink>}
     * @memberof V1Group
     */
    'inviteLinks'?: Array<V1GroupInviteLink>;
    /**
     * 
     * @type {Array<V1GroupActivity>}
     * @memberof V1Group
     */
    'activities'?: Array<V1GroupActivity>;
}
/**
 * 
 * @export
 * @interface V1GroupActivity
 */
export interface V1GroupActivity {
    /**
     * 
     * @type {string}
     * @memberof V1GroupActivity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupActivity
     */
    'groupId': string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupActivity
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupActivity
     */
    'event': string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupActivity
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface V1GroupConversation
 */
export interface V1GroupConversation {
    /**
     * 
     * @type {string}
     * @memberof V1GroupConversation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupConversation
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupConversation
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface V1GroupInvite
 */
export interface V1GroupInvite {
    /**
     * 
     * @type {string}
     * @memberof V1GroupInvite
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInvite
     */
    'groupId'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInvite
     */
    'senderAccountId': string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInvite
     */
    'recipientAccountId': string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInvite
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInvite
     */
    'validUntil': string;
}
/**
 * 
 * @export
 * @interface V1GroupInviteLink
 */
export interface V1GroupInviteLink {
    /**
     * 
     * @type {string}
     * @memberof V1GroupInviteLink
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInviteLink
     */
    'generatedByAccountId': string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInviteLink
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof V1GroupInviteLink
     */
    'validUntil': string;
}
/**
 * 
 * @export
 * @interface V1GroupMember
 */
export interface V1GroupMember {
    /**
     * 
     * @type {string}
     * @memberof V1GroupMember
     */
    'accountId': string;
    /**
     * 
     * @type {boolean}
     * @memberof V1GroupMember
     */
    'isAdmin': boolean;
    /**
     * 
     * @type {string}
     * @memberof V1GroupMember
     */
    'joinedAt': string;
}
/**
 * 
 * @export
 * @interface V1HttpError
 */
export interface V1HttpError {
    /**
     * 
     * @type {string}
     * @memberof V1HttpError
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const V1ImageType = {
    Jpeg: 'TYPE_JPEG',
    Png: 'TYPE_PNG'
} as const;

export type V1ImageType = typeof V1ImageType[keyof typeof V1ImageType];


/**
 * 
 * @export
 * @interface V1ImageWidget
 */
export interface V1ImageWidget {
    /**
     * 
     * @type {string}
     * @memberof V1ImageWidget
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof V1ImageWidget
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof V1ImageWidget
     */
    'caption'?: string;
}
/**
 * 
 * @export
 * @interface V1InsertBlockResponse
 */
export interface V1InsertBlockResponse {
    /**
     * 
     * @type {V1Block}
     * @memberof V1InsertBlockResponse
     */
    'block': V1Block;
}
/**
 * 
 * @export
 * @interface V1ListAccountsResponse
 */
export interface V1ListAccountsResponse {
    /**
     * 
     * @type {Array<V1Account>}
     * @memberof V1ListAccountsResponse
     */
    'accounts'?: Array<V1Account>;
}
/**
 * 
 * @export
 * @interface V1ListActivitiesResponse
 */
export interface V1ListActivitiesResponse {
    /**
     * 
     * @type {Array<V1GroupActivity>}
     * @memberof V1ListActivitiesResponse
     */
    'activities': Array<V1GroupActivity>;
}
/**
 * 
 * @export
 * @interface V1ListBlockCommentsResponse
 */
export interface V1ListBlockCommentsResponse {
    /**
     * 
     * @type {Array<BlockComment>}
     * @memberof V1ListBlockCommentsResponse
     */
    'comments'?: Array<BlockComment>;
}
/**
 * 
 * @export
 * @interface V1ListConversationMessagesResponse
 */
export interface V1ListConversationMessagesResponse {
    /**
     * 
     * @type {Array<V1ConversationMessage>}
     * @memberof V1ListConversationMessagesResponse
     */
    'messages'?: Array<V1ConversationMessage>;
}
/**
 * 
 * @export
 * @interface V1ListGroupsResponse
 */
export interface V1ListGroupsResponse {
    /**
     * 
     * @type {Array<V1Group>}
     * @memberof V1ListGroupsResponse
     */
    'groups'?: Array<V1Group>;
}
/**
 * 
 * @export
 * @interface V1ListInvitesResponse
 */
export interface V1ListInvitesResponse {
    /**
     * 
     * @type {Array<V1GroupInvite>}
     * @memberof V1ListInvitesResponse
     */
    'invites'?: Array<V1GroupInvite>;
}
/**
 * 
 * @export
 * @interface V1ListNotesResponse
 */
export interface V1ListNotesResponse {
    /**
     * 
     * @type {Array<V1Note>}
     * @memberof V1ListNotesResponse
     */
    'notes'?: Array<V1Note>;
}
/**
 * 
 * @export
 * @interface V1Note
 */
export interface V1Note {
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'groupId': string;
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'authorAccountId': string;
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'title': string;
    /**
     * 
     * @type {Array<V1Block>}
     * @memberof V1Note
     */
    'blocks'?: Array<V1Block>;
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'modifiedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Note
     */
    'analyzedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const V1NoteExportFormat = {
    Markdown: 'NOTE_EXPORT_FORMAT_MARKDOWN',
    Pdf: 'NOTE_EXPORT_FORMAT_PDF'
} as const;

export type V1NoteExportFormat = typeof V1NoteExportFormat[keyof typeof V1NoteExportFormat];


/**
 * 
 * @export
 * @interface V1Quiz
 */
export interface V1Quiz {
    /**
     * 
     * @type {Array<V1QuizQuestion>}
     * @memberof V1Quiz
     */
    'questions'?: Array<V1QuizQuestion>;
}
/**
 * 
 * @export
 * @interface V1QuizQuestion
 */
export interface V1QuizQuestion {
    /**
     * 
     * @type {string}
     * @memberof V1QuizQuestion
     */
    'question'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1QuizQuestion
     */
    'answers'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1QuizQuestion
     */
    'solutions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface V1Recipient
 */
export interface V1Recipient {
    /**
     * 
     * @type {string}
     * @memberof V1Recipient
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface V1RegisterUserToMobileBetaRequest
 */
export interface V1RegisterUserToMobileBetaRequest {
    /**
     * 
     * @type {string}
     * @memberof V1RegisterUserToMobileBetaRequest
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface V1SendConversationMessageResponse
 */
export interface V1SendConversationMessageResponse {
    /**
     * 
     * @type {V1ConversationMessage}
     * @memberof V1SendConversationMessageResponse
     */
    'message': V1ConversationMessage;
}
/**
 * 
 * @export
 * @interface V1SendInviteResponse
 */
export interface V1SendInviteResponse {
    /**
     * 
     * @type {V1GroupInvite}
     * @memberof V1SendInviteResponse
     */
    'invite': V1GroupInvite;
}
/**
 * 
 * @export
 * @interface V1StreamInvitesResponse
 */
export interface V1StreamInvitesResponse {
    /**
     * 
     * @type {Array<V1GroupInvite>}
     * @memberof V1StreamInvitesResponse
     */
    'invites'?: Array<V1GroupInvite>;
}
/**
 * 
 * @export
 * @interface V1SummarizeResponse
 */
export interface V1SummarizeResponse {
    /**
     * Small text output which summarizes the original entry.
     * @type {string}
     * @memberof V1SummarizeResponse
     */
    'summary'?: string;
}
/**
 * 
 * @export
 * @interface V1UpdateAccountPasswordResponse
 */
export interface V1UpdateAccountPasswordResponse {
    /**
     * 
     * @type {V1Account}
     * @memberof V1UpdateAccountPasswordResponse
     */
    'account': V1Account;
}
/**
 * 
 * @export
 * @interface V1UpdateAccountResponse
 */
export interface V1UpdateAccountResponse {
    /**
     * 
     * @type {V1Account}
     * @memberof V1UpdateAccountResponse
     */
    'account': V1Account;
}
/**
 * 
 * @export
 * @interface V1UpdateBlockIndexResponse
 */
export interface V1UpdateBlockIndexResponse {
    /**
     * 
     * @type {V1Block}
     * @memberof V1UpdateBlockIndexResponse
     */
    'block': V1Block;
}
/**
 * 
 * @export
 * @interface V1UpdateBlockResponse
 */
export interface V1UpdateBlockResponse {
    /**
     * 
     * @type {V1Block}
     * @memberof V1UpdateBlockResponse
     */
    'block': V1Block;
}
/**
 * 
 * @export
 * @interface V1UpdateConversationMessageResponse
 */
export interface V1UpdateConversationMessageResponse {
    /**
     * 
     * @type {V1ConversationMessage}
     * @memberof V1UpdateConversationMessageResponse
     */
    'message': V1ConversationMessage;
}
/**
 * 
 * @export
 * @interface V1UpdateConversationResponse
 */
export interface V1UpdateConversationResponse {
    /**
     * 
     * @type {V1GroupConversation}
     * @memberof V1UpdateConversationResponse
     */
    'conversation': V1GroupConversation;
}
/**
 * 
 * @export
 * @interface V1UpdateGroupResponse
 */
export interface V1UpdateGroupResponse {
    /**
     * 
     * @type {V1Group}
     * @memberof V1UpdateGroupResponse
     */
    'group': V1Group;
}
/**
 * 
 * @export
 * @interface V1UpdateMemberResponse
 */
export interface V1UpdateMemberResponse {
    /**
     * 
     * @type {V1GroupMember}
     * @memberof V1UpdateMemberResponse
     */
    'member': V1GroupMember;
}
/**
 * 
 * @export
 * @interface V1UpdateNoteResponse
 */
export interface V1UpdateNoteResponse {
    /**
     * 
     * @type {V1Note}
     * @memberof V1UpdateNoteResponse
     */
    'note': V1Note;
}
/**
 * 
 * @export
 * @interface V1ValidateAccountResponse
 */
export interface V1ValidateAccountResponse {
    /**
     * 
     * @type {V1Account}
     * @memberof V1ValidateAccountResponse
     */
    'account': V1Account;
}
/**
 * 
 * @export
 * @interface V1WebsiteWidget
 */
export interface V1WebsiteWidget {
    /**
     * 
     * @type {string}
     * @memberof V1WebsiteWidget
     */
    'keyword': string;
    /**
     * 
     * @type {string}
     * @memberof V1WebsiteWidget
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof V1WebsiteWidget
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof V1WebsiteWidget
     */
    'summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1WebsiteWidget
     */
    'imageUrl'?: string;
}
/**
 * 
 * @export
 * @interface V1Widget
 */
export interface V1Widget {
    /**
     * 
     * @type {V1WebsiteWidget}
     * @memberof V1Widget
     */
    'websiteWidget'?: V1WebsiteWidget;
    /**
     * 
     * @type {V1ImageWidget}
     * @memberof V1Widget
     */
    'imageWidget'?: V1ImageWidget;
    /**
     * 
     * @type {V1DefinitionWidget}
     * @memberof V1Widget
     */
    'definitionWidget'?: V1DefinitionWidget;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate using the email and password flow.
         * @param {V1AuthenticateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIAuthenticate: async (body: V1AuthenticateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAPIAuthenticate', 'body', body)
            const localVarPath = `/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticate using the Google OAuth flow.
         * @param {V1AuthenticateGoogleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIAuthenticateGoogle: async (body: V1AuthenticateGoogleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAPIAuthenticateGoogle', 'body', body)
            const localVarPath = `/authenticate/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an account using the email and password flow.
         * @param {V1CreateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPICreateAccount: async (body: V1CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAPICreateAccount', 'body', body)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be account owner.
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIDeleteAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAPIDeleteAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send email to account containing code to create a new password.
         * @param {V1ForgetAccountPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIForgetAccountPassword: async (body: V1ForgetAccountPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAPIForgetAccountPassword', 'body', body)
            const localVarPath = `/accounts/forget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Compare forgot password token provided by user with the one store in db.
         * @param {V1ForgetAccountPasswordValidateTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIForgetAccountPasswordValidateToken: async (body: V1ForgetAccountPasswordValidateTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAPIForgetAccountPasswordValidateToken', 'body', body)
            const localVarPath = `/accounts/forget/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Allows getting an account by ID or searching for one through email.
         * @param {string} accountId 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIGetAccount: async (accountId: string, email?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAPIGetAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Allows getting an account by ID or searching for one through email.
         * @param {V1GetAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIGetAccount2: async (body: V1GetAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAPIGetAccount2', 'body', body)
            const localVarPath = `/search/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIGetAccountProfilePicture: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAPIGetAccountProfilePicture', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/picture`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List users based on email regex.
         * @param {string} emailContains 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIListAccounts: async (emailContains: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailContains' is not null or undefined
            assertParamExists('accountsAPIListAccounts', 'emailContains', emailContains)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (emailContains !== undefined) {
                localVarQueryParameter['emailContains'] = emailContains;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Registers the user to the mobile application beta.
         * @param {V1RegisterUserToMobileBetaRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIRegisterUserToMobileBeta: async (body: V1RegisterUserToMobileBetaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAPIRegisterUserToMobileBeta', 'body', body)
            const localVarPath = `/beta/mobile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be account owner. Can only update `account.name`.
         * @param {string} accountId 
         * @param {V1Account} account 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIUpdateAccount: async (accountId: string, account: V1Account, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAPIUpdateAccount', 'accountId', accountId)
            // verify required parameter 'account' is not null or undefined
            assertParamExists('accountsAPIUpdateAccount', 'account', account)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(account, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update account password.
         * @param {string} accountId 
         * @param {AccountsAPIUpdateAccountPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIUpdateAccountPassword: async (accountId: string, body: AccountsAPIUpdateAccountPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAPIUpdateAccountPassword', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAPIUpdateAccountPassword', 'body', body)
            const localVarPath = `/accounts/{accountId}/password`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {AccountsAPIUploadAccountProfilePictureRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIUploadAccountProfilePicture: async (accountId: string, body: AccountsAPIUploadAccountProfilePictureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAPIUploadAccountProfilePicture', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAPIUploadAccountProfilePicture', 'body', body)
            const localVarPath = `/accounts/{accountId}/picture`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate account email.
         * @param {string} accountId 
         * @param {AccountsAPIValidateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIValidateAccount: async (accountId: string, body: AccountsAPIValidateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAPIValidateAccount', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAPIValidateAccount', 'body', body)
            const localVarPath = `/accounts/{accountId}/validate`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be recipient. Accepting an invitation automatically adds the recipient to the group and deletes the invite.
         * @param {string} groupId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIAcceptInvite: async (groupId: string, inviteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIAcceptInvite', 'groupId', groupId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('groupsAPIAcceptInvite', 'inviteId', inviteId)
            const localVarPath = `/groups/{groupId}/invites/{inviteId}/accept`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a group with a single administrator member (the authenticated user). Must be authenticated.
         * @param {V1CreateGroupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPICreateGroup: async (body: V1CreateGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('groupsAPICreateGroup', 'body', body)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group administrator. Deletes all the associated resources (members, notes).
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIDeleteGroup: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIDeleteGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be recipient. Deletes the invitation without making the recipient join the group.
         * @param {string} groupId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIDenyInvite: async (groupId: string, inviteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIDenyInvite', 'groupId', groupId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('groupsAPIDenyInvite', 'inviteId', inviteId)
            const localVarPath = `/groups/{groupId}/invites/{inviteId}/deny`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifierAccountId terminate background service dedicated to account_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIEndStreamInvites: async (identifierAccountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifierAccountId' is not null or undefined
            assertParamExists('groupsAPIEndStreamInvites', 'identifierAccountId', identifierAccountId)
            const localVarPath = `/groups/invites/{identifierAccountId}/stream/terminate`
                .replace(`{${"identifierAccountId"}}`, encodeURIComponent(String(identifierAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group member. generated_by_account_id defaults to the authenticated user.
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGenerateInviteLink: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIGenerateInviteLink', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/inviteLinks`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be a group member. Returns a signle activity in a group.
         * @param {string} groupId 
         * @param {string} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGetActivity: async (groupId: string, activityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIGetActivity', 'groupId', groupId)
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists('groupsAPIGetActivity', 'activityId', activityId)
            const localVarPath = `/groups/{groupId}/activity/{activityId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group member. If the caller is not a member but has been invited to the group or has an invite code link, it will access a limited view of the group.
         * @param {string} groupId 
         * @param {string} [inviteLinkCode] If the requester isn\&#39;t a member of the group nor have they been invited directly, they can provide an invite_link_code that will give them a public preview of the group they wish to join.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGetGroup: async (groupId: string, inviteLinkCode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIGetGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inviteLinkCode !== undefined) {
                localVarQueryParameter['inviteLinkCode'] = inviteLinkCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group administrator or sender or recipient.
         * @param {string} groupId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGetInvite: async (groupId: string, inviteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIGetInvite', 'groupId', groupId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('groupsAPIGetInvite', 'inviteId', inviteId)
            const localVarPath = `/groups/{groupId}/invites/{inviteId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group member.
         * @param {string} groupId 
         * @param {string} inviteLinkCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGetInviteLink: async (groupId: string, inviteLinkCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIGetInviteLink', 'groupId', groupId)
            // verify required parameter 'inviteLinkCode' is not null or undefined
            assertParamExists('groupsAPIGetInviteLink', 'inviteLinkCode', inviteLinkCode)
            const localVarPath = `/groups/{groupId}/inviteLinks/{inviteLinkCode}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"inviteLinkCode"}}`, encodeURIComponent(String(inviteLinkCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group member.
         * @param {string} groupId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGetMember: async (groupId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIGetMember', 'groupId', groupId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsAPIGetMember', 'accountId', accountId)
            const localVarPath = `/groups/{groupId}/members/{accountId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be a group member. List all the activities in a group.
         * @param {string} groupId 
         * @param {string} [accountId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIListActivities: async (groupId: string, accountId?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIListActivities', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/activity`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group member. Returns only the non-array fields of a group.
         * @param {string} accountId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIListGroups: async (accountId: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsAPIListGroups', 'accountId', accountId)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group administrator or sender or recipient.
         * @param {string} [senderAccountId] Returns only invites from sender.
         * @param {string} [recipientAccountId] Returns only invites destined to recipient.
         * @param {string} [groupId] Returns only invites for a given group.
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIListInvites: async (senderAccountId?: string, recipientAccountId?: string, groupId?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (senderAccountId !== undefined) {
                localVarQueryParameter['senderAccountId'] = senderAccountId;
            }

            if (recipientAccountId !== undefined) {
                localVarQueryParameter['recipientAccountId'] = recipientAccountId;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group administrator or sender or recipient.
         * @param {string} groupId Returns only invites for a given group.
         * @param {string} [senderAccountId] Returns only invites from sender.
         * @param {string} [recipientAccountId] Returns only invites destined to recipient.
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIListInvites2: async (groupId: string, senderAccountId?: string, recipientAccountId?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIListInvites2', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/invites`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (senderAccountId !== undefined) {
                localVarQueryParameter['senderAccountId'] = senderAccountId;
            }

            if (recipientAccountId !== undefined) {
                localVarQueryParameter['recipientAccountId'] = recipientAccountId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group administrator or the authenticated user removing itself from the group.
         * @param {string} groupId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIRemoveMember: async (groupId: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIRemoveMember', 'groupId', groupId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsAPIRemoveMember', 'accountId', accountId)
            const localVarPath = `/groups/{groupId}/members/{accountId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group administrator or sender. Deletes the invitation without making the recipient join the group.
         * @param {string} groupId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIRevokeInvite: async (groupId: string, inviteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIRevokeInvite', 'groupId', groupId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('groupsAPIRevokeInvite', 'inviteId', inviteId)
            const localVarPath = `/groups/{groupId}/invites/{inviteId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group member.
         * @param {string} groupId 
         * @param {string} inviteLinkCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIRevokeInviteLink: async (groupId: string, inviteLinkCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIRevokeInviteLink', 'groupId', groupId)
            // verify required parameter 'inviteLinkCode' is not null or undefined
            assertParamExists('groupsAPIRevokeInviteLink', 'inviteLinkCode', inviteLinkCode)
            const localVarPath = `/groups/{groupId}/inviteLinks/{inviteLinkCode}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"inviteLinkCode"}}`, encodeURIComponent(String(inviteLinkCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The sender defaults to the authenticated user. Must be group member.
         * @param {string} groupId 
         * @param {GroupsAPISendInviteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPISendInvite: async (groupId: string, body: GroupsAPISendInviteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPISendInvite', 'groupId', groupId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('groupsAPISendInvite', 'body', body)
            const localVarPath = `/groups/{groupId}/invites`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identifierAccountId Returns only invites destined to recipient.
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIStreamInvites: async (identifierAccountId: string, groupId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifierAccountId' is not null or undefined
            assertParamExists('groupsAPIStreamInvites', 'identifierAccountId', identifierAccountId)
            const localVarPath = `/groups/invites/{identifierAccountId}/stream`
                .replace(`{${"identifierAccountId"}}`, encodeURIComponent(String(identifierAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group administrator.
         * @param {string} groupId 
         * @param {GroupsAPIUpdateGroupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIUpdateGroup: async (groupId: string, body: GroupsAPIUpdateGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIUpdateGroup', 'groupId', groupId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('groupsAPIUpdateGroup', 'body', body)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group administrator. Can only update `role`.
         * @param {string} groupId 
         * @param {string} accountId 
         * @param {V1GroupMember} member 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIUpdateMember: async (groupId: string, accountId: string, member: V1GroupMember, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIUpdateMember', 'groupId', groupId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsAPIUpdateMember', 'accountId', accountId)
            // verify required parameter 'member' is not null or undefined
            assertParamExists('groupsAPIUpdateMember', 'member', member)
            const localVarPath = `/groups/{groupId}/members/{accountId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(member, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must not be group member. Makes the authenticated join the group on success.
         * @param {string} groupId 
         * @param {string} inviteLinkCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIUseInviteLink: async (groupId: string, inviteLinkCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsAPIUseInviteLink', 'groupId', groupId)
            // verify required parameter 'inviteLinkCode' is not null or undefined
            assertParamExists('groupsAPIUseInviteLink', 'inviteLinkCode', inviteLinkCode)
            const localVarPath = `/groups/{groupId}/inviteLinks/{inviteLinkCode}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"inviteLinkCode"}}`, encodeURIComponent(String(inviteLinkCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {NotesAPIChangeNoteEditPermissionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIChangeNoteEditPermission: async (groupId: string, noteId: string, body: NotesAPIChangeNoteEditPermissionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPIChangeNoteEditPermission', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesAPIChangeNoteEditPermission', 'noteId', noteId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('notesAPIChangeNoteEditPermission', 'body', body)
            const localVarPath = `/groups/{groupId}/notes/{noteId}/permission`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {NotesAPICreateBlockCommentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPICreateBlockComment: async (groupId: string, noteId: string, blockId: string, body: NotesAPICreateBlockCommentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPICreateBlockComment', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesAPICreateBlockComment', 'noteId', noteId)
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('notesAPICreateBlockComment', 'blockId', blockId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('notesAPICreateBlockComment', 'body', body)
            const localVarPath = `/groups/{groupId}/notes/{noteId}/{blockId}/comment`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)))
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group member, author_account_id defaults to the user making the request. Create a new note in database.
         * @param {string} groupId 
         * @param {NotesAPICreateNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPICreateNote: async (groupId: string, body: NotesAPICreateNoteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPICreateNote', 'groupId', groupId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('notesAPICreateNote', 'body', body)
            const localVarPath = `/groups/{groupId}/notes`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be author. Delete a block in a note and replace the indexes of the others.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIDeleteBlock: async (groupId: string, noteId: string, blockId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPIDeleteBlock', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesAPIDeleteBlock', 'noteId', noteId)
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('notesAPIDeleteBlock', 'blockId', blockId)
            const localVarPath = `/groups/{groupId}/notes/{noteId}/blocks/{blockId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)))
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIDeleteBlockComment: async (groupId: string, noteId: string, blockId: string, commentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPIDeleteBlockComment', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesAPIDeleteBlockComment', 'noteId', noteId)
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('notesAPIDeleteBlockComment', 'blockId', blockId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('notesAPIDeleteBlockComment', 'commentId', commentId)
            const localVarPath = `/groups/{groupId}/notes/{noteId}/{blockId}/comment/{commentId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)))
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be author. Delete a single note in database.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIDeleteNote: async (groupId: string, noteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPIDeleteNote', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesAPIDeleteNote', 'noteId', noteId)
            const localVarPath = `/groups/{groupId}/notes/{noteId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIGenerateQuiz: async (groupId: string, noteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPIGenerateQuiz', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesAPIGenerateQuiz', 'noteId', noteId)
            const localVarPath = `/groups/{groupId}/notes/{noteId}/quiz`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIGenerateSummary: async (groupId: string, noteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPIGenerateSummary', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesAPIGenerateSummary', 'noteId', noteId)
            const localVarPath = `/groups/{groupId}/notes/{noteId}/summary`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be group member or author. Return a note from id provided.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIGetNote: async (groupId: string, noteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPIGetNote', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesAPIGetNote', 'noteId', noteId)
            const localVarPath = `/groups/{groupId}/notes/{noteId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be author. Insert a block of content in a note at a specific index.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {NotesAPIInsertBlockRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIInsertBlock: async (groupId: string, noteId: string, body: NotesAPIInsertBlockRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPIInsertBlock', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesAPIInsertBlock', 'noteId', noteId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('notesAPIInsertBlock', 'body', body)
            const localVarPath = `/groups/{groupId}/notes/{noteId}/blocks`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIListBlockComments: async (groupId: string, noteId: string, blockId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPIListBlockComments', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesAPIListBlockComments', 'noteId', noteId)
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('notesAPIListBlockComments', 'blockId', blockId)
            const localVarPath = `/groups/{groupId}/notes/{noteId}/{blockId}/comments`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)))
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List notes in a group, authored by a user or both. Must have read access to the notes.
         * @param {string} [authorAccountId] 
         * @param {string} [groupId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIListNotes: async (authorAccountId?: string, groupId?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorAccountId !== undefined) {
                localVarQueryParameter['authorAccountId'] = authorAccountId;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List notes in a group, authored by a user or both. Must have read access to the notes.
         * @param {string} groupId 
         * @param {string} [authorAccountId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIListNotes2: async (groupId: string, authorAccountId?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPIListNotes2', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/notes`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorAccountId !== undefined) {
                localVarQueryParameter['authorAccountId'] = authorAccountId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be author. Update a block content.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {V1Block} block 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIUpdateBlock: async (groupId: string, noteId: string, blockId: string, block: V1Block, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPIUpdateBlock', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesAPIUpdateBlock', 'noteId', noteId)
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('notesAPIUpdateBlock', 'blockId', blockId)
            // verify required parameter 'block' is not null or undefined
            assertParamExists('notesAPIUpdateBlock', 'block', block)
            const localVarPath = `/groups/{groupId}/notes/{noteId}/blocks/{blockId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)))
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(block, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be author. Update a block index.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {NotesAPIUpdateBlockIndexRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIUpdateBlockIndex: async (groupId: string, noteId: string, blockId: string, body: NotesAPIUpdateBlockIndexRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPIUpdateBlockIndex', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesAPIUpdateBlockIndex', 'noteId', noteId)
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('notesAPIUpdateBlockIndex', 'blockId', blockId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('notesAPIUpdateBlockIndex', 'body', body)
            const localVarPath = `/groups/{groupId}/notes/{noteId}/blocks/{blockId}/index`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)))
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be author. Can only update `title` or `blocks`.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {V1Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIUpdateNote: async (groupId: string, noteId: string, note: V1Note, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('notesAPIUpdateNote', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('notesAPIUpdateNote', 'noteId', noteId)
            // verify required parameter 'note' is not null or undefined
            assertParamExists('notesAPIUpdateNote', 'note', note)
            const localVarPath = `/groups/{groupId}/notes/{noteId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(note, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Must be a group member. Returns all the relevent widgets from the given note id.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recommendationsAPIGenerateWidgets: async (groupId: string, noteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('recommendationsAPIGenerateWidgets', 'groupId', groupId)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('recommendationsAPIGenerateWidgets', 'noteId', noteId)
            const localVarPath = `/groups/{groupId}/notes/{noteId}/widgets`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authenticate using the email and password flow.
         * @param {V1AuthenticateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIAuthenticate(body: V1AuthenticateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1AuthenticateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIAuthenticate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Authenticate using the Google OAuth flow.
         * @param {V1AuthenticateGoogleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIAuthenticateGoogle(body: V1AuthenticateGoogleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1AuthenticateGoogleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIAuthenticateGoogle(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an account using the email and password flow.
         * @param {V1CreateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPICreateAccount(body: V1CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPICreateAccount(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be account owner.
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIDeleteAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIDeleteAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send email to account containing code to create a new password.
         * @param {V1ForgetAccountPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIForgetAccountPassword(body: V1ForgetAccountPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ForgetAccountPasswordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIForgetAccountPassword(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Compare forgot password token provided by user with the one store in db.
         * @param {V1ForgetAccountPasswordValidateTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIForgetAccountPasswordValidateToken(body: V1ForgetAccountPasswordValidateTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ForgetAccountPasswordValidateTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIForgetAccountPasswordValidateToken(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Allows getting an account by ID or searching for one through email.
         * @param {string} accountId 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIGetAccount(accountId: string, email?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIGetAccount(accountId, email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Allows getting an account by ID or searching for one through email.
         * @param {V1GetAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIGetAccount2(body: V1GetAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIGetAccount2(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIGetAccountProfilePicture(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetAccountProfilePictureResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIGetAccountProfilePicture(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List users based on email regex.
         * @param {string} emailContains 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIListAccounts(emailContains: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ListAccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIListAccounts(emailContains, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Registers the user to the mobile application beta.
         * @param {V1RegisterUserToMobileBetaRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIRegisterUserToMobileBeta(body: V1RegisterUserToMobileBetaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIRegisterUserToMobileBeta(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be account owner. Can only update `account.name`.
         * @param {string} accountId 
         * @param {V1Account} account 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIUpdateAccount(accountId: string, account: V1Account, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1UpdateAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIUpdateAccount(accountId, account, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update account password.
         * @param {string} accountId 
         * @param {AccountsAPIUpdateAccountPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIUpdateAccountPassword(accountId: string, body: AccountsAPIUpdateAccountPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1UpdateAccountPasswordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIUpdateAccountPassword(accountId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {AccountsAPIUploadAccountProfilePictureRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIUploadAccountProfilePicture(accountId: string, body: AccountsAPIUploadAccountProfilePictureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIUploadAccountProfilePicture(accountId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate account email.
         * @param {string} accountId 
         * @param {AccountsAPIValidateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAPIValidateAccount(accountId: string, body: AccountsAPIValidateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ValidateAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAPIValidateAccount(accountId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be recipient. Accepting an invitation automatically adds the recipient to the group and deletes the invite.
         * @param {string} groupId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIAcceptInvite(groupId: string, inviteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1AcceptInviteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIAcceptInvite(groupId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a group with a single administrator member (the authenticated user). Must be authenticated.
         * @param {V1CreateGroupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPICreateGroup(body: V1CreateGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPICreateGroup(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group administrator. Deletes all the associated resources (members, notes).
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIDeleteGroup(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIDeleteGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be recipient. Deletes the invitation without making the recipient join the group.
         * @param {string} groupId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIDenyInvite(groupId: string, inviteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIDenyInvite(groupId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} identifierAccountId terminate background service dedicated to account_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIEndStreamInvites(identifierAccountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIEndStreamInvites(identifierAccountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group member. generated_by_account_id defaults to the authenticated user.
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIGenerateInviteLink(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GenerateInviteLinkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIGenerateInviteLink(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be a group member. Returns a signle activity in a group.
         * @param {string} groupId 
         * @param {string} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIGetActivity(groupId: string, activityId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetActivityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIGetActivity(groupId, activityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group member. If the caller is not a member but has been invited to the group or has an invite code link, it will access a limited view of the group.
         * @param {string} groupId 
         * @param {string} [inviteLinkCode] If the requester isn\&#39;t a member of the group nor have they been invited directly, they can provide an invite_link_code that will give them a public preview of the group they wish to join.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIGetGroup(groupId: string, inviteLinkCode?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIGetGroup(groupId, inviteLinkCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group administrator or sender or recipient.
         * @param {string} groupId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIGetInvite(groupId: string, inviteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetInviteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIGetInvite(groupId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group member.
         * @param {string} groupId 
         * @param {string} inviteLinkCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIGetInviteLink(groupId: string, inviteLinkCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetInviteLinkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIGetInviteLink(groupId, inviteLinkCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group member.
         * @param {string} groupId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIGetMember(groupId: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIGetMember(groupId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be a group member. List all the activities in a group.
         * @param {string} groupId 
         * @param {string} [accountId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIListActivities(groupId: string, accountId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ListActivitiesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIListActivities(groupId, accountId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group member. Returns only the non-array fields of a group.
         * @param {string} accountId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIListGroups(accountId: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ListGroupsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIListGroups(accountId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group administrator or sender or recipient.
         * @param {string} [senderAccountId] Returns only invites from sender.
         * @param {string} [recipientAccountId] Returns only invites destined to recipient.
         * @param {string} [groupId] Returns only invites for a given group.
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIListInvites(senderAccountId?: string, recipientAccountId?: string, groupId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ListInvitesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIListInvites(senderAccountId, recipientAccountId, groupId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group administrator or sender or recipient.
         * @param {string} groupId Returns only invites for a given group.
         * @param {string} [senderAccountId] Returns only invites from sender.
         * @param {string} [recipientAccountId] Returns only invites destined to recipient.
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIListInvites2(groupId: string, senderAccountId?: string, recipientAccountId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ListInvitesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIListInvites2(groupId, senderAccountId, recipientAccountId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group administrator or the authenticated user removing itself from the group.
         * @param {string} groupId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIRemoveMember(groupId: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIRemoveMember(groupId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group administrator or sender. Deletes the invitation without making the recipient join the group.
         * @param {string} groupId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIRevokeInvite(groupId: string, inviteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIRevokeInvite(groupId, inviteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group member.
         * @param {string} groupId 
         * @param {string} inviteLinkCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIRevokeInviteLink(groupId: string, inviteLinkCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIRevokeInviteLink(groupId, inviteLinkCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary The sender defaults to the authenticated user. Must be group member.
         * @param {string} groupId 
         * @param {GroupsAPISendInviteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPISendInvite(groupId: string, body: GroupsAPISendInviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1SendInviteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPISendInvite(groupId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} identifierAccountId Returns only invites destined to recipient.
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIStreamInvites(identifierAccountId: string, groupId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamResultOfV1StreamInvitesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIStreamInvites(identifierAccountId, groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group administrator.
         * @param {string} groupId 
         * @param {GroupsAPIUpdateGroupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIUpdateGroup(groupId: string, body: GroupsAPIUpdateGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1UpdateGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIUpdateGroup(groupId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group administrator. Can only update `role`.
         * @param {string} groupId 
         * @param {string} accountId 
         * @param {V1GroupMember} member 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIUpdateMember(groupId: string, accountId: string, member: V1GroupMember, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1UpdateMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIUpdateMember(groupId, accountId, member, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must not be group member. Makes the authenticated join the group on success.
         * @param {string} groupId 
         * @param {string} inviteLinkCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsAPIUseInviteLink(groupId: string, inviteLinkCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsAPIUseInviteLink(groupId, inviteLinkCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {NotesAPIChangeNoteEditPermissionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIChangeNoteEditPermission(groupId: string, noteId: string, body: NotesAPIChangeNoteEditPermissionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIChangeNoteEditPermission(groupId, noteId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {NotesAPICreateBlockCommentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPICreateBlockComment(groupId: string, noteId: string, blockId: string, body: NotesAPICreateBlockCommentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateBlockCommentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPICreateBlockComment(groupId, noteId, blockId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group member, author_account_id defaults to the user making the request. Create a new note in database.
         * @param {string} groupId 
         * @param {NotesAPICreateNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPICreateNote(groupId: string, body: NotesAPICreateNoteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateNoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPICreateNote(groupId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be author. Delete a block in a note and replace the indexes of the others.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIDeleteBlock(groupId: string, noteId: string, blockId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIDeleteBlock(groupId, noteId, blockId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIDeleteBlockComment(groupId: string, noteId: string, blockId: string, commentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIDeleteBlockComment(groupId, noteId, blockId, commentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be author. Delete a single note in database.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIDeleteNote(groupId: string, noteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIDeleteNote(groupId, noteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIGenerateQuiz(groupId: string, noteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GenerateQuizResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIGenerateQuiz(groupId, noteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIGenerateSummary(groupId: string, noteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GenerateSummaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIGenerateSummary(groupId, noteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be group member or author. Return a note from id provided.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIGetNote(groupId: string, noteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetNoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIGetNote(groupId, noteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be author. Insert a block of content in a note at a specific index.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {NotesAPIInsertBlockRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIInsertBlock(groupId: string, noteId: string, body: NotesAPIInsertBlockRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1InsertBlockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIInsertBlock(groupId, noteId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIListBlockComments(groupId: string, noteId: string, blockId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ListBlockCommentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIListBlockComments(groupId, noteId, blockId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List notes in a group, authored by a user or both. Must have read access to the notes.
         * @param {string} [authorAccountId] 
         * @param {string} [groupId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIListNotes(authorAccountId?: string, groupId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ListNotesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIListNotes(authorAccountId, groupId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List notes in a group, authored by a user or both. Must have read access to the notes.
         * @param {string} groupId 
         * @param {string} [authorAccountId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIListNotes2(groupId: string, authorAccountId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ListNotesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIListNotes2(groupId, authorAccountId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be author. Update a block content.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {V1Block} block 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIUpdateBlock(groupId: string, noteId: string, blockId: string, block: V1Block, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1UpdateBlockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIUpdateBlock(groupId, noteId, blockId, block, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be author. Update a block index.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {NotesAPIUpdateBlockIndexRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIUpdateBlockIndex(groupId: string, noteId: string, blockId: string, body: NotesAPIUpdateBlockIndexRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1UpdateBlockIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIUpdateBlockIndex(groupId, noteId, blockId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be author. Can only update `title` or `blocks`.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {V1Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesAPIUpdateNote(groupId: string, noteId: string, note: V1Note, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1UpdateNoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesAPIUpdateNote(groupId, noteId, note, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Must be a group member. Returns all the relevent widgets from the given note id.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recommendationsAPIGenerateWidgets(groupId: string, noteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GenerateWidgetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recommendationsAPIGenerateWidgets(groupId, noteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Authenticate using the email and password flow.
         * @param {V1AuthenticateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIAuthenticate(body: V1AuthenticateRequest, options?: any): AxiosPromise<V1AuthenticateResponse> {
            return localVarFp.accountsAPIAuthenticate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticate using the Google OAuth flow.
         * @param {V1AuthenticateGoogleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIAuthenticateGoogle(body: V1AuthenticateGoogleRequest, options?: any): AxiosPromise<V1AuthenticateGoogleResponse> {
            return localVarFp.accountsAPIAuthenticateGoogle(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an account using the email and password flow.
         * @param {V1CreateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPICreateAccount(body: V1CreateAccountRequest, options?: any): AxiosPromise<V1CreateAccountResponse> {
            return localVarFp.accountsAPICreateAccount(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be account owner.
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIDeleteAccount(accountId: string, options?: any): AxiosPromise<object> {
            return localVarFp.accountsAPIDeleteAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send email to account containing code to create a new password.
         * @param {V1ForgetAccountPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIForgetAccountPassword(body: V1ForgetAccountPasswordRequest, options?: any): AxiosPromise<V1ForgetAccountPasswordResponse> {
            return localVarFp.accountsAPIForgetAccountPassword(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Compare forgot password token provided by user with the one store in db.
         * @param {V1ForgetAccountPasswordValidateTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIForgetAccountPasswordValidateToken(body: V1ForgetAccountPasswordValidateTokenRequest, options?: any): AxiosPromise<V1ForgetAccountPasswordValidateTokenResponse> {
            return localVarFp.accountsAPIForgetAccountPasswordValidateToken(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Allows getting an account by ID or searching for one through email.
         * @param {string} accountId 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIGetAccount(accountId: string, email?: string, options?: any): AxiosPromise<V1GetAccountResponse> {
            return localVarFp.accountsAPIGetAccount(accountId, email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Allows getting an account by ID or searching for one through email.
         * @param {V1GetAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIGetAccount2(body: V1GetAccountRequest, options?: any): AxiosPromise<V1GetAccountResponse> {
            return localVarFp.accountsAPIGetAccount2(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIGetAccountProfilePicture(accountId: string, options?: any): AxiosPromise<V1GetAccountProfilePictureResponse> {
            return localVarFp.accountsAPIGetAccountProfilePicture(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List users based on email regex.
         * @param {string} emailContains 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIListAccounts(emailContains: string, limit?: number, offset?: number, options?: any): AxiosPromise<V1ListAccountsResponse> {
            return localVarFp.accountsAPIListAccounts(emailContains, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Registers the user to the mobile application beta.
         * @param {V1RegisterUserToMobileBetaRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIRegisterUserToMobileBeta(body: V1RegisterUserToMobileBetaRequest, options?: any): AxiosPromise<object> {
            return localVarFp.accountsAPIRegisterUserToMobileBeta(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be account owner. Can only update `account.name`.
         * @param {string} accountId 
         * @param {V1Account} account 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIUpdateAccount(accountId: string, account: V1Account, options?: any): AxiosPromise<V1UpdateAccountResponse> {
            return localVarFp.accountsAPIUpdateAccount(accountId, account, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update account password.
         * @param {string} accountId 
         * @param {AccountsAPIUpdateAccountPasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIUpdateAccountPassword(accountId: string, body: AccountsAPIUpdateAccountPasswordRequest, options?: any): AxiosPromise<V1UpdateAccountPasswordResponse> {
            return localVarFp.accountsAPIUpdateAccountPassword(accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {AccountsAPIUploadAccountProfilePictureRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIUploadAccountProfilePicture(accountId: string, body: AccountsAPIUploadAccountProfilePictureRequest, options?: any): AxiosPromise<object> {
            return localVarFp.accountsAPIUploadAccountProfilePicture(accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate account email.
         * @param {string} accountId 
         * @param {AccountsAPIValidateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAPIValidateAccount(accountId: string, body: AccountsAPIValidateAccountRequest, options?: any): AxiosPromise<V1ValidateAccountResponse> {
            return localVarFp.accountsAPIValidateAccount(accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be recipient. Accepting an invitation automatically adds the recipient to the group and deletes the invite.
         * @param {string} groupId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIAcceptInvite(groupId: string, inviteId: string, options?: any): AxiosPromise<V1AcceptInviteResponse> {
            return localVarFp.groupsAPIAcceptInvite(groupId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a group with a single administrator member (the authenticated user). Must be authenticated.
         * @param {V1CreateGroupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPICreateGroup(body: V1CreateGroupRequest, options?: any): AxiosPromise<V1CreateGroupResponse> {
            return localVarFp.groupsAPICreateGroup(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group administrator. Deletes all the associated resources (members, notes).
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIDeleteGroup(groupId: string, options?: any): AxiosPromise<object> {
            return localVarFp.groupsAPIDeleteGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be recipient. Deletes the invitation without making the recipient join the group.
         * @param {string} groupId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIDenyInvite(groupId: string, inviteId: string, options?: any): AxiosPromise<object> {
            return localVarFp.groupsAPIDenyInvite(groupId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifierAccountId terminate background service dedicated to account_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIEndStreamInvites(identifierAccountId: string, options?: any): AxiosPromise<object> {
            return localVarFp.groupsAPIEndStreamInvites(identifierAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group member. generated_by_account_id defaults to the authenticated user.
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGenerateInviteLink(groupId: string, options?: any): AxiosPromise<V1GenerateInviteLinkResponse> {
            return localVarFp.groupsAPIGenerateInviteLink(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be a group member. Returns a signle activity in a group.
         * @param {string} groupId 
         * @param {string} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGetActivity(groupId: string, activityId: string, options?: any): AxiosPromise<V1GetActivityResponse> {
            return localVarFp.groupsAPIGetActivity(groupId, activityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group member. If the caller is not a member but has been invited to the group or has an invite code link, it will access a limited view of the group.
         * @param {string} groupId 
         * @param {string} [inviteLinkCode] If the requester isn\&#39;t a member of the group nor have they been invited directly, they can provide an invite_link_code that will give them a public preview of the group they wish to join.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGetGroup(groupId: string, inviteLinkCode?: string, options?: any): AxiosPromise<V1GetGroupResponse> {
            return localVarFp.groupsAPIGetGroup(groupId, inviteLinkCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group administrator or sender or recipient.
         * @param {string} groupId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGetInvite(groupId: string, inviteId: string, options?: any): AxiosPromise<V1GetInviteResponse> {
            return localVarFp.groupsAPIGetInvite(groupId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group member.
         * @param {string} groupId 
         * @param {string} inviteLinkCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGetInviteLink(groupId: string, inviteLinkCode: string, options?: any): AxiosPromise<V1GetInviteLinkResponse> {
            return localVarFp.groupsAPIGetInviteLink(groupId, inviteLinkCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group member.
         * @param {string} groupId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIGetMember(groupId: string, accountId: string, options?: any): AxiosPromise<V1GetMemberResponse> {
            return localVarFp.groupsAPIGetMember(groupId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be a group member. List all the activities in a group.
         * @param {string} groupId 
         * @param {string} [accountId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIListActivities(groupId: string, accountId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<V1ListActivitiesResponse> {
            return localVarFp.groupsAPIListActivities(groupId, accountId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group member. Returns only the non-array fields of a group.
         * @param {string} accountId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIListGroups(accountId: string, limit?: number, offset?: number, options?: any): AxiosPromise<V1ListGroupsResponse> {
            return localVarFp.groupsAPIListGroups(accountId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group administrator or sender or recipient.
         * @param {string} [senderAccountId] Returns only invites from sender.
         * @param {string} [recipientAccountId] Returns only invites destined to recipient.
         * @param {string} [groupId] Returns only invites for a given group.
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIListInvites(senderAccountId?: string, recipientAccountId?: string, groupId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<V1ListInvitesResponse> {
            return localVarFp.groupsAPIListInvites(senderAccountId, recipientAccountId, groupId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group administrator or sender or recipient.
         * @param {string} groupId Returns only invites for a given group.
         * @param {string} [senderAccountId] Returns only invites from sender.
         * @param {string} [recipientAccountId] Returns only invites destined to recipient.
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIListInvites2(groupId: string, senderAccountId?: string, recipientAccountId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<V1ListInvitesResponse> {
            return localVarFp.groupsAPIListInvites2(groupId, senderAccountId, recipientAccountId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group administrator or the authenticated user removing itself from the group.
         * @param {string} groupId 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIRemoveMember(groupId: string, accountId: string, options?: any): AxiosPromise<object> {
            return localVarFp.groupsAPIRemoveMember(groupId, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group administrator or sender. Deletes the invitation without making the recipient join the group.
         * @param {string} groupId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIRevokeInvite(groupId: string, inviteId: string, options?: any): AxiosPromise<object> {
            return localVarFp.groupsAPIRevokeInvite(groupId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group member.
         * @param {string} groupId 
         * @param {string} inviteLinkCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIRevokeInviteLink(groupId: string, inviteLinkCode: string, options?: any): AxiosPromise<object> {
            return localVarFp.groupsAPIRevokeInviteLink(groupId, inviteLinkCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary The sender defaults to the authenticated user. Must be group member.
         * @param {string} groupId 
         * @param {GroupsAPISendInviteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPISendInvite(groupId: string, body: GroupsAPISendInviteRequest, options?: any): AxiosPromise<V1SendInviteResponse> {
            return localVarFp.groupsAPISendInvite(groupId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} identifierAccountId Returns only invites destined to recipient.
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIStreamInvites(identifierAccountId: string, groupId?: string, options?: any): AxiosPromise<StreamResultOfV1StreamInvitesResponse> {
            return localVarFp.groupsAPIStreamInvites(identifierAccountId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group administrator.
         * @param {string} groupId 
         * @param {GroupsAPIUpdateGroupRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIUpdateGroup(groupId: string, body: GroupsAPIUpdateGroupRequest, options?: any): AxiosPromise<V1UpdateGroupResponse> {
            return localVarFp.groupsAPIUpdateGroup(groupId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group administrator. Can only update `role`.
         * @param {string} groupId 
         * @param {string} accountId 
         * @param {V1GroupMember} member 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIUpdateMember(groupId: string, accountId: string, member: V1GroupMember, options?: any): AxiosPromise<V1UpdateMemberResponse> {
            return localVarFp.groupsAPIUpdateMember(groupId, accountId, member, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must not be group member. Makes the authenticated join the group on success.
         * @param {string} groupId 
         * @param {string} inviteLinkCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsAPIUseInviteLink(groupId: string, inviteLinkCode: string, options?: any): AxiosPromise<object> {
            return localVarFp.groupsAPIUseInviteLink(groupId, inviteLinkCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {NotesAPIChangeNoteEditPermissionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIChangeNoteEditPermission(groupId: string, noteId: string, body: NotesAPIChangeNoteEditPermissionRequest, options?: any): AxiosPromise<object> {
            return localVarFp.notesAPIChangeNoteEditPermission(groupId, noteId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {NotesAPICreateBlockCommentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPICreateBlockComment(groupId: string, noteId: string, blockId: string, body: NotesAPICreateBlockCommentRequest, options?: any): AxiosPromise<V1CreateBlockCommentResponse> {
            return localVarFp.notesAPICreateBlockComment(groupId, noteId, blockId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group member, author_account_id defaults to the user making the request. Create a new note in database.
         * @param {string} groupId 
         * @param {NotesAPICreateNoteRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPICreateNote(groupId: string, body: NotesAPICreateNoteRequest, options?: any): AxiosPromise<V1CreateNoteResponse> {
            return localVarFp.notesAPICreateNote(groupId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be author. Delete a block in a note and replace the indexes of the others.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIDeleteBlock(groupId: string, noteId: string, blockId: string, options?: any): AxiosPromise<object> {
            return localVarFp.notesAPIDeleteBlock(groupId, noteId, blockId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIDeleteBlockComment(groupId: string, noteId: string, blockId: string, commentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.notesAPIDeleteBlockComment(groupId, noteId, blockId, commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be author. Delete a single note in database.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIDeleteNote(groupId: string, noteId: string, options?: any): AxiosPromise<object> {
            return localVarFp.notesAPIDeleteNote(groupId, noteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIGenerateQuiz(groupId: string, noteId: string, options?: any): AxiosPromise<V1GenerateQuizResponse> {
            return localVarFp.notesAPIGenerateQuiz(groupId, noteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIGenerateSummary(groupId: string, noteId: string, options?: any): AxiosPromise<V1GenerateSummaryResponse> {
            return localVarFp.notesAPIGenerateSummary(groupId, noteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be group member or author. Return a note from id provided.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIGetNote(groupId: string, noteId: string, options?: any): AxiosPromise<V1GetNoteResponse> {
            return localVarFp.notesAPIGetNote(groupId, noteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be author. Insert a block of content in a note at a specific index.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {NotesAPIInsertBlockRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIInsertBlock(groupId: string, noteId: string, body: NotesAPIInsertBlockRequest, options?: any): AxiosPromise<V1InsertBlockResponse> {
            return localVarFp.notesAPIInsertBlock(groupId, noteId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIListBlockComments(groupId: string, noteId: string, blockId: string, options?: any): AxiosPromise<V1ListBlockCommentsResponse> {
            return localVarFp.notesAPIListBlockComments(groupId, noteId, blockId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List notes in a group, authored by a user or both. Must have read access to the notes.
         * @param {string} [authorAccountId] 
         * @param {string} [groupId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIListNotes(authorAccountId?: string, groupId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<V1ListNotesResponse> {
            return localVarFp.notesAPIListNotes(authorAccountId, groupId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List notes in a group, authored by a user or both. Must have read access to the notes.
         * @param {string} groupId 
         * @param {string} [authorAccountId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIListNotes2(groupId: string, authorAccountId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<V1ListNotesResponse> {
            return localVarFp.notesAPIListNotes2(groupId, authorAccountId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be author. Update a block content.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {V1Block} block 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIUpdateBlock(groupId: string, noteId: string, blockId: string, block: V1Block, options?: any): AxiosPromise<V1UpdateBlockResponse> {
            return localVarFp.notesAPIUpdateBlock(groupId, noteId, blockId, block, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be author. Update a block index.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {string} blockId 
         * @param {NotesAPIUpdateBlockIndexRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIUpdateBlockIndex(groupId: string, noteId: string, blockId: string, body: NotesAPIUpdateBlockIndexRequest, options?: any): AxiosPromise<V1UpdateBlockIndexResponse> {
            return localVarFp.notesAPIUpdateBlockIndex(groupId, noteId, blockId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be author. Can only update `title` or `blocks`.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {V1Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesAPIUpdateNote(groupId: string, noteId: string, note: V1Note, options?: any): AxiosPromise<V1UpdateNoteResponse> {
            return localVarFp.notesAPIUpdateNote(groupId, noteId, note, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Must be a group member. Returns all the relevent widgets from the given note id.
         * @param {string} groupId 
         * @param {string} noteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recommendationsAPIGenerateWidgets(groupId: string, noteId: string, options?: any): AxiosPromise<V1GenerateWidgetsResponse> {
            return localVarFp.recommendationsAPIGenerateWidgets(groupId, noteId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Authenticate using the email and password flow.
     * @param {V1AuthenticateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIAuthenticate(body: V1AuthenticateRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIAuthenticate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticate using the Google OAuth flow.
     * @param {V1AuthenticateGoogleRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIAuthenticateGoogle(body: V1AuthenticateGoogleRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIAuthenticateGoogle(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an account using the email and password flow.
     * @param {V1CreateAccountRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPICreateAccount(body: V1CreateAccountRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPICreateAccount(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be account owner.
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIDeleteAccount(accountId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIDeleteAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send email to account containing code to create a new password.
     * @param {V1ForgetAccountPasswordRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIForgetAccountPassword(body: V1ForgetAccountPasswordRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIForgetAccountPassword(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Compare forgot password token provided by user with the one store in db.
     * @param {V1ForgetAccountPasswordValidateTokenRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIForgetAccountPasswordValidateToken(body: V1ForgetAccountPasswordValidateTokenRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIForgetAccountPasswordValidateToken(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Allows getting an account by ID or searching for one through email.
     * @param {string} accountId 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIGetAccount(accountId: string, email?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIGetAccount(accountId, email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Allows getting an account by ID or searching for one through email.
     * @param {V1GetAccountRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIGetAccount2(body: V1GetAccountRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIGetAccount2(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIGetAccountProfilePicture(accountId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIGetAccountProfilePicture(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List users based on email regex.
     * @param {string} emailContains 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIListAccounts(emailContains: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIListAccounts(emailContains, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Registers the user to the mobile application beta.
     * @param {V1RegisterUserToMobileBetaRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIRegisterUserToMobileBeta(body: V1RegisterUserToMobileBetaRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIRegisterUserToMobileBeta(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be account owner. Can only update `account.name`.
     * @param {string} accountId 
     * @param {V1Account} account 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIUpdateAccount(accountId: string, account: V1Account, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIUpdateAccount(accountId, account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update account password.
     * @param {string} accountId 
     * @param {AccountsAPIUpdateAccountPasswordRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIUpdateAccountPassword(accountId: string, body: AccountsAPIUpdateAccountPasswordRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIUpdateAccountPassword(accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {AccountsAPIUploadAccountProfilePictureRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIUploadAccountProfilePicture(accountId: string, body: AccountsAPIUploadAccountProfilePictureRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIUploadAccountProfilePicture(accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate account email.
     * @param {string} accountId 
     * @param {AccountsAPIValidateAccountRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountsAPIValidateAccount(accountId: string, body: AccountsAPIValidateAccountRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountsAPIValidateAccount(accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be recipient. Accepting an invitation automatically adds the recipient to the group and deletes the invite.
     * @param {string} groupId 
     * @param {string} inviteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIAcceptInvite(groupId: string, inviteId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIAcceptInvite(groupId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a group with a single administrator member (the authenticated user). Must be authenticated.
     * @param {V1CreateGroupRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPICreateGroup(body: V1CreateGroupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPICreateGroup(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group administrator. Deletes all the associated resources (members, notes).
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIDeleteGroup(groupId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIDeleteGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be recipient. Deletes the invitation without making the recipient join the group.
     * @param {string} groupId 
     * @param {string} inviteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIDenyInvite(groupId: string, inviteId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIDenyInvite(groupId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifierAccountId terminate background service dedicated to account_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIEndStreamInvites(identifierAccountId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIEndStreamInvites(identifierAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group member. generated_by_account_id defaults to the authenticated user.
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIGenerateInviteLink(groupId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIGenerateInviteLink(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be a group member. Returns a signle activity in a group.
     * @param {string} groupId 
     * @param {string} activityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIGetActivity(groupId: string, activityId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIGetActivity(groupId, activityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group member. If the caller is not a member but has been invited to the group or has an invite code link, it will access a limited view of the group.
     * @param {string} groupId 
     * @param {string} [inviteLinkCode] If the requester isn\&#39;t a member of the group nor have they been invited directly, they can provide an invite_link_code that will give them a public preview of the group they wish to join.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIGetGroup(groupId: string, inviteLinkCode?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIGetGroup(groupId, inviteLinkCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group administrator or sender or recipient.
     * @param {string} groupId 
     * @param {string} inviteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIGetInvite(groupId: string, inviteId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIGetInvite(groupId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group member.
     * @param {string} groupId 
     * @param {string} inviteLinkCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIGetInviteLink(groupId: string, inviteLinkCode: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIGetInviteLink(groupId, inviteLinkCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group member.
     * @param {string} groupId 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIGetMember(groupId: string, accountId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIGetMember(groupId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be a group member. List all the activities in a group.
     * @param {string} groupId 
     * @param {string} [accountId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIListActivities(groupId: string, accountId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIListActivities(groupId, accountId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group member. Returns only the non-array fields of a group.
     * @param {string} accountId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIListGroups(accountId: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIListGroups(accountId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group administrator or sender or recipient.
     * @param {string} [senderAccountId] Returns only invites from sender.
     * @param {string} [recipientAccountId] Returns only invites destined to recipient.
     * @param {string} [groupId] Returns only invites for a given group.
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIListInvites(senderAccountId?: string, recipientAccountId?: string, groupId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIListInvites(senderAccountId, recipientAccountId, groupId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group administrator or sender or recipient.
     * @param {string} groupId Returns only invites for a given group.
     * @param {string} [senderAccountId] Returns only invites from sender.
     * @param {string} [recipientAccountId] Returns only invites destined to recipient.
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIListInvites2(groupId: string, senderAccountId?: string, recipientAccountId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIListInvites2(groupId, senderAccountId, recipientAccountId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group administrator or the authenticated user removing itself from the group.
     * @param {string} groupId 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIRemoveMember(groupId: string, accountId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIRemoveMember(groupId, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group administrator or sender. Deletes the invitation without making the recipient join the group.
     * @param {string} groupId 
     * @param {string} inviteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIRevokeInvite(groupId: string, inviteId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIRevokeInvite(groupId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group member.
     * @param {string} groupId 
     * @param {string} inviteLinkCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIRevokeInviteLink(groupId: string, inviteLinkCode: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIRevokeInviteLink(groupId, inviteLinkCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary The sender defaults to the authenticated user. Must be group member.
     * @param {string} groupId 
     * @param {GroupsAPISendInviteRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPISendInvite(groupId: string, body: GroupsAPISendInviteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPISendInvite(groupId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} identifierAccountId Returns only invites destined to recipient.
     * @param {string} [groupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIStreamInvites(identifierAccountId: string, groupId?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIStreamInvites(identifierAccountId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group administrator.
     * @param {string} groupId 
     * @param {GroupsAPIUpdateGroupRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIUpdateGroup(groupId: string, body: GroupsAPIUpdateGroupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIUpdateGroup(groupId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group administrator. Can only update `role`.
     * @param {string} groupId 
     * @param {string} accountId 
     * @param {V1GroupMember} member 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIUpdateMember(groupId: string, accountId: string, member: V1GroupMember, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIUpdateMember(groupId, accountId, member, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must not be group member. Makes the authenticated join the group on success.
     * @param {string} groupId 
     * @param {string} inviteLinkCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public groupsAPIUseInviteLink(groupId: string, inviteLinkCode: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).groupsAPIUseInviteLink(groupId, inviteLinkCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {NotesAPIChangeNoteEditPermissionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIChangeNoteEditPermission(groupId: string, noteId: string, body: NotesAPIChangeNoteEditPermissionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIChangeNoteEditPermission(groupId, noteId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {string} blockId 
     * @param {NotesAPICreateBlockCommentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPICreateBlockComment(groupId: string, noteId: string, blockId: string, body: NotesAPICreateBlockCommentRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPICreateBlockComment(groupId, noteId, blockId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group member, author_account_id defaults to the user making the request. Create a new note in database.
     * @param {string} groupId 
     * @param {NotesAPICreateNoteRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPICreateNote(groupId: string, body: NotesAPICreateNoteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPICreateNote(groupId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be author. Delete a block in a note and replace the indexes of the others.
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {string} blockId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIDeleteBlock(groupId: string, noteId: string, blockId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIDeleteBlock(groupId, noteId, blockId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {string} blockId 
     * @param {string} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIDeleteBlockComment(groupId: string, noteId: string, blockId: string, commentId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIDeleteBlockComment(groupId, noteId, blockId, commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be author. Delete a single note in database.
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIDeleteNote(groupId: string, noteId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIDeleteNote(groupId, noteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIGenerateQuiz(groupId: string, noteId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIGenerateQuiz(groupId, noteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIGenerateSummary(groupId: string, noteId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIGenerateSummary(groupId, noteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be group member or author. Return a note from id provided.
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIGetNote(groupId: string, noteId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIGetNote(groupId, noteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be author. Insert a block of content in a note at a specific index.
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {NotesAPIInsertBlockRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIInsertBlock(groupId: string, noteId: string, body: NotesAPIInsertBlockRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIInsertBlock(groupId, noteId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {string} blockId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIListBlockComments(groupId: string, noteId: string, blockId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIListBlockComments(groupId, noteId, blockId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List notes in a group, authored by a user or both. Must have read access to the notes.
     * @param {string} [authorAccountId] 
     * @param {string} [groupId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIListNotes(authorAccountId?: string, groupId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIListNotes(authorAccountId, groupId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List notes in a group, authored by a user or both. Must have read access to the notes.
     * @param {string} groupId 
     * @param {string} [authorAccountId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIListNotes2(groupId: string, authorAccountId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIListNotes2(groupId, authorAccountId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be author. Update a block content.
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {string} blockId 
     * @param {V1Block} block 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIUpdateBlock(groupId: string, noteId: string, blockId: string, block: V1Block, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIUpdateBlock(groupId, noteId, blockId, block, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be author. Update a block index.
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {string} blockId 
     * @param {NotesAPIUpdateBlockIndexRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIUpdateBlockIndex(groupId: string, noteId: string, blockId: string, body: NotesAPIUpdateBlockIndexRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIUpdateBlockIndex(groupId, noteId, blockId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be author. Can only update `title` or `blocks`.
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {V1Note} note 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notesAPIUpdateNote(groupId: string, noteId: string, note: V1Note, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notesAPIUpdateNote(groupId, noteId, note, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Must be a group member. Returns all the relevent widgets from the given note id.
     * @param {string} groupId 
     * @param {string} noteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public recommendationsAPIGenerateWidgets(groupId: string, noteId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).recommendationsAPIGenerateWidgets(groupId, noteId, options).then((request) => request(this.axios, this.basePath));
    }
}



